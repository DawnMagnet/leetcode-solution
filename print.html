<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LeetCode Solution - 力扣题解</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?68e5a42781c7cf226eb26bac2cf1a765";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="written_at_front.html">引言</a></li><li class="chapter-item expanded affix "><a href="leanote.html">关于从蚂蚁笔记迁移而来的说明</a></li><li class="chapter-item expanded "><a href="special/SUMMAR.html"><strong aria-hidden="true">1.</strong> 特辑</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="special/leetcode-cup-2021-autumn-group.html"><strong aria-hidden="true">1.1.</strong> 2021力扣杯秋季编程大赛-战队赛复盘</a></li></ol></li><li class="chapter-item expanded "><a href="2021/SUMMARY.html"><strong aria-hidden="true">2.</strong> 2021年</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2021/10/SUMMARY.html"><strong aria-hidden="true">2.1.</strong> 10月</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2021/10/7-No.434.html"><strong aria-hidden="true">2.1.1.</strong> 7日 -  字符串中的单词数</a></li><li class="chapter-item expanded "><a href="2021/10/6-No.414.html"><strong aria-hidden="true">2.1.2.</strong> 6日 -  第三大的数</a></li><li class="chapter-item expanded "><a href="2021/10/5-No.284.html"><strong aria-hidden="true">2.1.3.</strong> 5日 -  窥探迭代器</a></li><li class="chapter-item expanded "><a href="2021/10/4-No.482.html"><strong aria-hidden="true">2.1.4.</strong> 4日 -  密钥格式化</a></li><li class="chapter-item expanded "><a href="2021/10/3-No.166.html"><strong aria-hidden="true">2.1.5.</strong> 3日 -  分数到小数</a></li><li class="chapter-item expanded "><a href="2021/10/2-No.405.html"><strong aria-hidden="true">2.1.6.</strong> 2日 -  数字转换为十六进制数</a></li><li class="chapter-item expanded "><a href="2021/10/1-No.1436.html"><strong aria-hidden="true">2.1.7.</strong> 1日 -  旅行终点站</a></li></ol></li><li class="chapter-item expanded "><a href="2021/9/SUMMARY.html"><strong aria-hidden="true">2.2.</strong> 9月</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2021/9/30-No.223.html"><strong aria-hidden="true">2.2.1.</strong> 30日 -  矩形面积</a></li><li class="chapter-item expanded "><a href="2021/9/29-No.517.html"><strong aria-hidden="true">2.2.2.</strong> 29日 -  超级洗衣机</a></li><li class="chapter-item expanded "><a href="2021/9/28-No.437.html"><strong aria-hidden="true">2.2.3.</strong> 28日 -  路径总和 III</a></li><li class="chapter-item expanded "><a href="2021/9/27-No.639.html"><strong aria-hidden="true">2.2.4.</strong> 27日 -  解码方法 II</a></li><li class="chapter-item expanded "><a href="2021/9/26-No.371.html"><strong aria-hidden="true">2.2.5.</strong> 26日 -  两整数之和</a></li><li class="chapter-item expanded "><a href="2021/9/25-No.583.html"><strong aria-hidden="true">2.2.6.</strong> 25日 -  两个字符串的删除操作</a></li><li class="chapter-item expanded "><a href="2021/9/24-No.430.html"><strong aria-hidden="true">2.2.7.</strong> 24日 -  扁平化多级双向链表</a></li><li class="chapter-item expanded "><a href="2021/9/23-No.326.html"><strong aria-hidden="true">2.2.8.</strong> 23日 -  3的幂</a></li><li class="chapter-item expanded "><a href="2021/9/22-No.725.html"><strong aria-hidden="true">2.2.9.</strong> 22日 -  分隔链表</a></li></ol></li><li class="chapter-item expanded "><a href="2021/8/SUMMARY.html"><strong aria-hidden="true">2.3.</strong> 8月</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2021/8/14-No.1853.html"><strong aria-hidden="true">2.3.1.</strong> 14日 -  统计不开心的朋友</a></li><li class="chapter-item expanded "><a href="2021/8/13-No.233.html"><strong aria-hidden="true">2.3.2.</strong> 13日 -  数字1的个数</a></li><li class="chapter-item expanded "><a href="2021/8/12-No.516.html"><strong aria-hidden="true">2.3.3.</strong> 12日 -  最长回文子序列</a></li><li class="chapter-item expanded "><a href="2021/8/11-No.446.html"><strong aria-hidden="true">2.3.4.</strong> 11日 -  等差数列划分 II - 子序列</a></li><li class="chapter-item expanded "><a href="2021/8/10-No.413.html"><strong aria-hidden="true">2.3.5.</strong> 10日 -  等差数列划分</a></li><li class="chapter-item expanded "><a href="2021/8/9-No.313.html"><strong aria-hidden="true">2.3.6.</strong> 9日 -  超级丑数</a></li><li class="chapter-item expanded "><a href="2021/8/8-No.1137.html"><strong aria-hidden="true">2.3.7.</strong> 8日 -  第N个泰波那契数</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">LeetCode Solution - 力扣题解</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/DawnMagnet/leetcode-solution.git" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="引言"><a class="header" href="#引言">引言</a></h1>
<p><a href="https://app.travis-ci.com/DawnMagnet/Leetcode-Solution"><img src="https://app.travis-ci.com/DawnMagnet/Leetcode-Solution.svg?branch=master" alt="Build Status" /></a></p>
<p><a href="https://gitpod.io/#https://github.com/DawnMagnet/leetcode-solution"><img src="https://gitpod.io/button/open-in-gitpod.svg" alt="Open in Gitpod" /></a></p>
<p>本书为个人在刷题过程中的心得和体会。<br />
主要题目来源为<a href="https://www.leetcode-cn.com">力扣-中国站 - LeetCode-cn</a><br />
主要刷题语言为 <a href="https://www.rust-lang.org/">Rust</a> / C++<br />
欢迎加微信 axccjqh 交流，备注 leetcode-solution 和必要的个人信息。</p>
<hr />
<ul>
<li>TIPS:本站题解已经按照时间倒序排序，且包含模糊搜索功能。</li>
<li>感谢<a href="https://www.travis-ci.com/">Travis-CI</a>,<a href="https://github.com/rust-lang/rust">Rust语言</a>和<a href="https://github.com/rust-lang/mdBook">mdBook</a>，本书就是构建在其之上。</li>
<li>如过觉得本项目好，可以点个<a href="https://github.com/DawnMagnet/leetcode-solution">Star</a>。请点击右上角的Github图标进入本项目的<a href="https://github.com/DawnMagnet/leetcode-solution">Github页面</a>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="关于从蚂蚁笔记迁移而来的说明"><a class="header" href="#关于从蚂蚁笔记迁移而来的说明">关于从蚂蚁笔记迁移而来的说明</a></h1>
<p>之前是在<a href="http://www.leanote.com">蚂蚁笔记</a>上进行写作。但因为诸多问题，将其迁移到GitHub Pages上来进行维护。<br />
如需阅览之前的笔记，请[点击下载(LeetCode-Solution-pre.zip)(共有93篇)</p>
<ul>
<li>可能会比较乱，因为没有按照时间加标签，但根据题号还是可以找到指定的题目的。</li>
</ul>
<p><img src="./leanote.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="2021-秋季力扣杯---战队赛复盘"><a class="header" href="#2021-秋季力扣杯---战队赛复盘">2021 秋季力扣杯 - 战队赛复盘</a></h1>
<h2 id="写在前面"><a class="header" href="#写在前面">写在前面</a></h2>
<p><img src="special/./leetcode-cup-2021%E7%A7%8B%E6%88%98%E9%98%9F%E8%B5%9B.png" alt="" />
<img src="special/./leetcode-cup-2021%E7%A7%8B%E6%88%98%E9%98%9F%E8%B5%9B-1.png" alt="" />
今年发挥还算挺不错的。以后再接再励！<br />
我 30 分钟写完了 2、4 两道题，队友一小时多写完了 1、3 两道题，然后就是啥都不会的几个小时。。。</p>
<p>争取以后不会出现这种情况。</p>
<h2 id="a-hrefhttpsleetcode-cncomproblemssz59z6第一题-开幕式焰火a"><a class="header" href="#a-hrefhttpsleetcode-cncomproblemssz59z6第一题-开幕式焰火a"><a href="https://leetcode-cn.com/problems/sZ59z6/">第一题 开幕式焰火</a></a></h2>
<h3 id="11-题目"><a class="header" href="#11-题目">1.1 题目</a></h3>
<div class="css-330z23" style="padding: 0px; margin: 13px 0px;"><p>「力扣挑战赛」开幕式开始了，空中绽放了一颗二叉树形的巨型焰火。<br>
给定一棵二叉树 <code>root</code> 代表焰火，节点值表示巨型焰火这一位置的颜色种类。请帮小扣计算巨型焰火有多少种不同的颜色。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>root = [1,3,2,1,null,2]</code></p>
<p>输出：<code>3</code></p>
<p>解释：焰火中有 3 个不同的颜色，值分别为 1、2、3</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>root = [3,3,3]</code></p>
<p>输出：<code>1</code></p>
<p>解释：焰火中仅出现 1 个颜色，值为 3</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= 节点个数 &lt;= 1000</code></li>
<li><code>1 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
<h3 id="12-思路分析"><a class="header" href="#12-思路分析">1.2 思路分析</a></h3>
<p>数组 dp 存一下状态就行了，没有出现过就加一次。</p>
<h3 id="13-代码"><a class="header" href="#13-代码">1.3 代码</a></h3>
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool dp[1005];
    int count = 0;
    void deal(TreeNode * root) {
        if (!root) return ;
        if (!dp[root-&gt;val]) {
            count++;
            dp[root-&gt;val] = true;
        }
        deal(root-&gt;left);
        deal(root-&gt;right);
    }
    int numColor(TreeNode* root) {
        deal(root);
        return count;
    }
};
</code></pre>
<h2 id="a-hrefhttpsleetcode-cncomproblemskplevh第二题-自行车炫技赛场a"><a class="header" href="#a-hrefhttpsleetcode-cncomproblemskplevh第二题-自行车炫技赛场a"><a href="https://leetcode-cn.com/problems/kplEvH/">第二题 自行车炫技赛场</a></a></h2>
<h3 id="21-题目"><a class="header" href="#21-题目">2.1 题目</a></h3>
<div class="css-330z23" style="padding: 0px; margin: 13px 0px;"><p>「力扣挑战赛」中 <code>N*M</code> 大小的自行车炫技赛场的场地由一片连绵起伏的上下坡组成，场地的高度值记录于二维数组 <code>terrain</code> 中，场地的减速值记录于二维数组 <code>obstacle</code> 中。</p>
<ul>
<li>若选手骑着自行车从高度为 <code>h1</code> 且减速值为 <code>o1</code> 的位置到高度为 <code>h2</code> 且减速值为 <code>o2</code> 的相邻位置（上下左右四个方向），速度变化值为 <code>h1-h2-o2</code>（负值减速，正值增速）。</li>
</ul>
<p>选手初始位于坐标 <code>position</code> 处且初始速度为 1，请问选手可以刚好到其他哪些位置时速度依旧为 1。请以二维数组形式返回这些位置。若有多个位置则按行坐标升序排列，若有多个位置行坐标相同则按列坐标升序排列。</p>
<p><strong>注意：</strong> 骑行过程中速度不能为零或负值</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>position = [0,0], terrain = [[0,0],[0,0]], obstacle = [[0,0],[0,0]]</code></p>
<p>输出：<code>[[0,1],[1,0],[1,1]]</code></p>
<p>解释：<br>
由于当前场地属于平地，根据上面的规则，选手从<code>[0,0]</code>的位置出发都能刚好在其他处的位置速度为 1。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>position = [1,1], terrain = [[5,0],[0,6]], obstacle = [[0,6],[7,0]]</code></p>
<p>输出：<code>[[0,1]]</code></p>
<p>解释：<br>
选手从 <code>[1,1]</code> 处的位置出发，到 <code>[0,1]</code> 处的位置时恰好速度为 1。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == terrain.length == obstacle.length</code></li>
<li><code>m == terrain[i].length == obstacle[i].length</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= m &lt;= 100</code></li>
<li><code>0 &lt;= terrain[i][j], obstacle[i][j] &lt;= 100</code></li>
<li><code>position.length == 2</code></li>
<li><code>0 &lt;= position[0] &lt; n</code></li>
<li><code>0 &lt;= position[1] &lt; m</code></li>
</ul>
</div>
<h3 id="22-思路分析"><a class="header" href="#22-思路分析">2.2 思路分析</a></h3>
<p>这道题是一个比较基础的 dfs 思路。
可能会要使用记忆化的技术去重。
仔细读题后发现，自行车到达一个地方，并非一定会有相同的速度，也就是说，不同的路径到达一个地方，速度可能并不相同。
在这种情况下，我们必须得记录一下，如果两次到达同一个地方，具有相同的速度，我们就可以考虑不再继续。如果不去判断这一点，就会导致循环的出现，也就是示例 1 中出现的情况，如果我们不判断重复，一定会导致死循环。</p>
<p>所以总结一下，思路就是 dfs 加上记忆化去重（剪枝）。只有两次到达同一个地方并且具有相同的速度，才会是剪枝条件。</p>
<p>我的代码中主要分成了两块，一块是主函数，一块是 dfs，dfs 函数接受三个参数，也就是当前的 x，y 坐标和 speed 速度。
当<code>passed[x][y][speed]</code>为<code>true</code>时候，就说明之前以相同的速度遍历过相同的地方，而且无需再遍历一次。<code>res[x][y]</code>为<code>true</code>的时候说明该坐标是答案的一个候选坐标。接下来就是非常常规的往四个方向进行遍历。速度小于 0 就截断之类的基操。</p>
<p>主函数中主要是处理了一下输入输出的逻辑，存了一些全局变量，对输出的答案格式做了一个简单的操作，包括将 res 变成答案所需的形式。</p>
<h3 id="23-c代码"><a class="header" href="#23-c代码">2.3 C++代码</a></h3>
<pre><code class="language-cpp">using VI = vector&lt;int&gt;;
using VVI = vector&lt;VI&gt;;
const VI direc = {0, 1, 0, -1, 0};
class Solution {
public:
    VVI t, o;
    bool res[100][100] = {};
    bool passed[100][100][105] = {};
    int n, m;
    void dfs(int x, int y, int speed) {
        if (speed == 1) res[x][y] = true;
        if (speed &lt; 1) return;
        if (passed[x][y][speed]) {
            return;
        }
        passed[x][y][speed] = true;
        for (int i = 0; i &lt; 4; ++i) {
            int xt = x + direc[i];
            int yt = y + direc[i + 1];
            if (xt &gt;= 0 &amp;&amp; yt &gt;= 0 &amp;&amp; xt &lt; n &amp;&amp; yt &lt; m)
                dfs(xt, yt, speed + t[x][y] - t[xt][yt] - o[xt][yt]);
        }
    }
    VVI bicycleYard(VI&amp; p, VVI&amp; terrain, VVI&amp; obstacle) {
        t = terrain;
        o = obstacle;
        n = t.size();
        m = t[0].size();
        int x = p[0], y = p[1];
        dfs(x, y, 1);
        VVI res_v;
        res[x][y] = false;
        for (int i = 0; i &lt; 100; ++i)
            for (int j = 0; j &lt; 100; ++j)
                if (res[i][j])
                    res_v.push_back({i, j});
        return res_v;
    }
};
</code></pre>
<h2 id="a-hrefhttpsleetcode-cncomproblems05zedj第三题-志愿者调配a"><a class="header" href="#a-hrefhttpsleetcode-cncomproblems05zedj第三题-志愿者调配a"><a href="https://leetcode-cn.com/problems/05ZEDJ/">第三题 志愿者调配</a></a></h2>
<h3 id="31-题目"><a class="header" href="#31-题目">3.1 题目</a></h3>
<div class="css-330z23" style="padding: 0px; margin: 13px 0px;"><p>「力扣挑战赛」有 <code>n</code> 个比赛场馆（场馆编号从 <code>0</code> 开始），场馆之间的通道分布情况记录于二维数组 <code>edges</code> 中，<code>edges[i]= [x, y]</code> 表示第 <code>i</code> 条通道连接场馆 <code>x</code> 和场馆 <code>y</code>(即两个场馆相邻)。初始每个场馆中都有一定人数的志愿者（不同场馆人数可能不同），后续 <code>m</code> 天每天均会根据赛事热度进行志愿者人数调配。调配方案分为如下三种：</p>
<ol>
<li>将编号为 <code>idx</code> 的场馆内的志愿者人数减半；</li>
<li>将编号为 <code>idx</code> 的场馆相邻的场馆的志愿者人数都加上编号为 <code>idx</code> 的场馆的志愿者人数；</li>
<li>将编号为 <code>idx</code> 的场馆相邻的场馆的志愿者人数都减去编号为 <code>idx</code> 的场馆的志愿者人数。</li>
</ol>
<p>所有的调配信息记录于数组 <code>plans</code> 中，<code>plans[i] = [num,idx]</code> 表示第 <code>i</code> 天对编号 <code>idx</code> 的场馆执行了第 <code>num</code> 种调配方案。<br>
在比赛结束后对调配方案进行复盘时，不慎将第 <code>0</code> 个场馆的<strong>最终</strong>志愿者人数丢失，只保留了<strong>初始</strong>所有场馆的志愿者总人数 <code>totalNum</code> ，以及记录了第 <code>1 ~ n-1</code> 个场馆的<strong>最终</strong>志愿者人数的一维数组 <code>finalCnt</code>。请你根据现有的信息求出初始每个场馆的志愿者人数，并按场馆编号顺序返回志愿者人数列表。</p>
<p><strong>注意：</strong></p>
<ul>
<li>测试数据保证当某场馆进行第一种调配时，该场馆的志愿者人数一定为偶数；</li>
<li>测试数据保证当某场馆进行第三种调配时，该场馆的相邻场馆志愿者人数不为负数；</li>
<li>测试数据保证比赛开始时每个场馆的志愿者人数都不超过 <code>10^9</code>；</li>
<li>测试数据保证给定的场馆间的道路分布情况中不会出现自环、重边的情况。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><img src="special/./leetcode-cup-1.png" alt="image.png" onerror="this.src='data:image/svg+xml,%3Csvg height=\'150\' viewBox=\'0 0 150 150\' width=\'150\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cpath d=\'m2465 2286.42347-18.95363-18.92555-50.0112 43.79935-24.62708-24.5906-33.41155 24.5906-22.99654-17.22567v-73.0716c0-2.20914 1.79086-4 4-4h142c2.20914 0 4 1.79086 4 4zm-122-25.59081c5.52285 0 10-4.47052 10-9.98518 0-5.51467-4.47715-9.98519-10-9.98519s-10 4.47052-10 9.98519c0 5.51466 4.47715 9.98518 10 9.98518zm122 40.89296v61.27438c0 2.20914-1.79086 4-4 4h-142c-2.20914 0-4-1.79086-4-4v-53.62625l22.99654 17.22567 33.41155-24.5906 24.62708 24.5906 50.0112-43.79935z\' fill=\'%23eee\' fill-rule=\'evenodd\' transform=\'translate(-2315 -2217)\'/%3E%3C/svg%3E'; "><br>
输入：<br>
<code>finalCnt = [1,16], totalNum = 21, edges = [[0,1],[1,2]], plans = [[2,1],[1,0],[3,0]]</code></p>
<p>输出：<code>[5,7,9]</code></p>
<p>解释：<br>
<img src="special/./leetcode-cup-2.png" alt="image.png" height="200" onerror="this.src='data:image/svg+xml,%3Csvg height=\'150\' viewBox=\'0 0 150 150\' width=\'150\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cpath d=\'m2465 2286.42347-18.95363-18.92555-50.0112 43.79935-24.62708-24.5906-33.41155 24.5906-22.99654-17.22567v-73.0716c0-2.20914 1.79086-4 4-4h142c2.20914 0 4 1.79086 4 4zm-122-25.59081c5.52285 0 10-4.47052 10-9.98518 0-5.51467-4.47715-9.98519-10-9.98519s-10 4.47052-10 9.98519c0 5.51466 4.47715 9.98518 10 9.98518zm122 40.89296v61.27438c0 2.20914-1.79086 4-4 4h-142c-2.20914 0-4-1.79086-4-4v-53.62625l22.99654 17.22567 33.41155-24.5906 24.62708 24.5906 50.0112-43.79935z\' fill=\'%23eee\' fill-rule=\'evenodd\' transform=\'translate(-2315 -2217)\'/%3E%3C/svg%3E'; "></p>
</blockquote>
<p><strong>示例 2 ：</strong></p>
<blockquote>
<p>输入：<br>
<code>finalCnt = [4,13,4,3,8], totalNum = 54, edges = [[0,3],[1,3],[4,3],[2,3],[2,5]], plans = [[1,1],[3,3],[2,5],[1,0]]</code></p>
<p>输出：<code>[10,16,9,4,7,8]</code></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 5*10^4</code></li>
<li><code>1 &lt;= edges.length &lt;= min((n * (n - 1)) / 2, 5*10^4)</code></li>
<li><code>0 &lt;= edges[i][0], edges[i][1] &lt; n</code></li>
<li><code>1 &lt;= plans.length &lt;= 10</code></li>
<li><code>1 &lt;= plans[i][0] &lt;=3</code></li>
<li><code>0 &lt;= plans[i][1] &lt; n</code></li>
<li><code>finalCnt.length = n-1</code></li>
<li><code>0 &lt;= finalCnt[i] &lt; 10^9</code></li>
<li><code>0 &lt;= totalNum &lt; 5*10^13</code></li>
</ul>
</div>
<h3 id="32-思路分析"><a class="header" href="#32-思路分析">3.2 思路分析</a></h3>
<p>我们只有一个值不知道，就是当前（最后时刻）第 0 号位的人数。
通过观察题目不难得出，三个操作都是线性操作，而且我们准确地知道每一步的操作，也就是说，只要知道知道了最后一个时刻的第 0 号位的人数，我们就可以严丝合缝地将结果递推到第一步。并且，在此时，第一步的总和应当严格等于<code>totalNum</code>。</p>
<p>既然如此，我们不妨设一个变量 x，作为最后时刻第 0 号位的人数。逆推来完成最终的推理，推理到第一步之后，每一个场馆的人数都应该是一个关于变量 x 的一次函数，我们将其求和之后仍然是一个一次函数，这个一次函数最终等于 <code>totalNum</code> ，代入就可以求得 x，代入每个场馆的表达式中即可获得每个场馆在第一步时的人数。</p>
<p>在具体代码中，设置两个数组 <code>x_param</code> 和 <code>c_param</code> ，分别代表指定场馆一次函数中的 x 系数项和常数项。最终递推回第一步，求得 <code>x_param_sum</code> 与 <code>c_param_sum</code> 。求解 x 的方程为:</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">am</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">am</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10903em;">lN</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span><br />
简单变换后得到:</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6300139999999999em;vertical-align:-0.5700069999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.060007em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7046857142857144em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.8971428571428572em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">am</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mopen mtight">[</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">]</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5350070000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">lN</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">am</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mopen mtight">[</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">]</span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5700069999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>最后代入到表达式中即可完成计算。</p>
<h3 id="33-c代码"><a class="header" href="#33-c代码">3.3 C++代码</a></h3>
<pre><code class="language-cpp">using VI = vector&lt;int&gt;;
using VVI = vector&lt;VI&gt;;
using ll = long long;
class Solution {
public:
    VI volunteerDeployment(VI&amp; finalCnt, ll totalNum, VVI&amp; edges, VVI&amp; plans) {
        VI m[50005];
        int n = finalCnt.size() + 1;
        // x系数和常数
        int x_param[50005] = {}, c_param[50005] = {};
        for (auto &amp; edge : edges) {
            m[edge[0]].push_back(edge[1]);
            m[edge[1]].push_back(edge[0]);
        }
        x_param[0] = 1;
        for (int i = 0; i &lt; n - 1; ++i)
            c_param[i + 1] = finalCnt[i];
        while (plans.size()) {
            int kind = plans.back()[0];
            int place = plans.back()[1];
            plans.pop_back();
            if (kind == 1) {
                x_param[place] *= 2;
                c_param[place] *= 2;
            } else if (kind == 2) {
                for (auto &amp; nxt : m[place]) {
                    x_param[nxt] -= x_param[place];
                    c_param[nxt] -= c_param[place];
                }
            } else {
                for (auto &amp; nxt : m[place]) {
                    x_param[nxt] += x_param[place];
                    c_param[nxt] += c_param[place];
                }
            }
        }
        ll x_param_sum = 0, c_param_sum = 0;
        for (int i = 0; i &lt; n; ++i) {
            x_param_sum += x_param[i];
            c_param_sum += c_param[i];
        }
        // 方程: x_param_sum * x + c_param_sum = totalNum
        int x = (totalNum - c_param_sum) / x_param_sum;
        vector&lt;int&gt; res(n);
        for (int i = 0; i &lt; n; ++i)
            res[i] = x_param[i] * x + c_param[i];
        return res;
    }
};
</code></pre>
<h2 id="a-hrefhttpsleetcode-cncomproblemsops9bm第四题-入场安检a"><a class="header" href="#a-hrefhttpsleetcode-cncomproblemsops9bm第四题-入场安检a"><a href="https://leetcode-cn.com/problems/oPs9Bm/">第四题 入场安检</a></a></h2>
<h3 id="41-题目"><a class="header" href="#41-题目">4.1 题目</a></h3>
<div class="css-330z23" style="padding: 0px; margin: 13px 0px;"><p>「力扣挑战赛」 的入场仪式马上就要开始了，由于安保工作的需要，设置了可容纳人数总和为 <code>M</code> 的 <code>N</code> 个安检室，<code>capacities[i]</code> 记录第 <code>i</code> 个安检室可容纳人数。安检室拥有两种类型：</p>
<ul>
<li>先进先出：在安检室中的所有观众中，最早进入安检室的观众最先离开</li>
<li>后进先出：在安检室中的所有观众中，最晚进入安检室的观众最先离开</li>
</ul>
<p align="center"><img src="https://pic.leetcode-cn.com/1628843202-cdFPSt-c24754f1a5ff56989340ba5004dc5eda.gif" alt="c24754f1a5ff56989340ba5004dc5eda.gif"></p>
<p>恰好 <code>M+1</code> 位入场的观众（编号从 0 开始）需要排队<strong>依次</strong>入场安检， 入场安检的规则如下：</p>
<ul>
<li>观众需要先进入编号 <code>0</code> 的安检室</li>
<li>当观众将进入编号 <code>i</code> 的安检室时（<code>0 &lt;= i &lt; N</code>)，
<ul>
<li>若安检室未到达可容纳人数上限，该观众可直接进入；</li>
<li>若安检室已到达可容纳人数上限，在该观众进入安检室之前需根据当前安检室类型选择一位观众离开后才能进入；</li>
</ul>
</li>
<li>当观众离开编号 <code>i</code> 的安检室时 （<code>0 &lt;= i &lt; N-1</code>)，将进入编号 <code>i+1</code> 的安检室接受安检。</li>
</ul>
<p>若可以任意设定每个安检室的类型，请问有多少种设定安检室类型的方案可以使得编号 <code>k</code> 的观众第一个通过最后一个安检室入场。</p>
<p><strong>注意：</strong></p>
<ul>
<li>观众不可主动离开安检室，只有当安检室容纳人数达到上限，且又有新观众需要进入时，才可根据安检室的类型选择一位观众离开；</li>
<li>由于方案数可能过大，请将答案对 <code>1000000007</code> 取模后返回。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>capacities = [2,2,3], k = 2</code></p>
<p>输出：<code>2</code><br>
解释：<br>
存在两种设定的 <code>2</code> 种方案：</p>
<ul>
<li>方案 1：将编号为 <code>0</code> 、<code>1</code> 的实验室设置为 <strong>后进先出</strong> 的类型，编号为 <code>2</code> 的实验室设置为 <strong>先进先出</strong> 的类型；</li>
<li>方案 2：将编号为 <code>0</code> 、<code>1</code> 的实验室设置为 <strong>先进先出</strong> 的类型，编号为 <code>2</code> 的实验室设置为 <strong>后进先出</strong> 的类型。</li>
</ul>
<p>以下是方案 1 的示意图：<br>
<img src="https://pic.leetcode-cn.com/1628841618-bFKsnt-c60e38199a225ad62f13b954872edf9b.gif" alt="c60e38199a225ad62f13b954872edf9b.gif"></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>capacities = [3,3], k = 3</code></p>
<p>输出：<code>0</code></p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：<code>capacities = [4,3,2,2], k = 6</code></p>
<p>输出：<code>2</code></p>
</blockquote>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= capacities.length &lt;= 200</code></li>
<li><code>1 &lt;= capacities[i] &lt;= 200</code></li>
<li><code>0 &lt;= k &lt;= sum(capacities)</code></li>
</ul>
</div>
<h3 id="42-思路分析"><a class="header" href="#42-思路分析">4.2 思路分析</a></h3>
<p>本题注意观察题目即可发现，先进先出对应的数据结构为队列，后进先出对应的数据结构为栈。
而注意看第二个gif，我们发现，当一个容器（实验室，我们在此统称为容器）为队列时，第一个进入的第一个出队列，也就是说，一个队列对于改变流程中的第一个人没任何影响。对比着来看栈，我们发现，一个长度为2的栈必须先填充1个元素，这一个元素就相当于固定在此处，没法移动，也就是说，对于流程中的第一个人，一个长度为<code>c</code>的栈能够拦截<code>c-1</code>个人。</p>
<p>那么就很简单了。因为我们想要让第<code>k</code>个人达到对首，我们必须使用栈来拦截前<code>k</code>个人。</p>
<p>所以我们把这道题翻译成一个我们喜闻乐见的形式：</p>
<pre><code class="language-markdown">有`N`个硬币，每个的金额都在`cap`数组中给出（需要一个减1操作）。我们从前往后选，求最终金额为`k`的方案数。
</code></pre>
<p>是不是一下就简单了呢！</p>
<p>最终的做法就是一个非常简单的dp。因为一个硬币只能用一次，所以要控制dp的方向。</p>
<h3 id="43-c代码"><a class="header" href="#43-c代码">4.3 C++代码</a></h3>
<pre><code class="language-cpp">const int md = 1000000007;
class Solution {
public:
    int securityCheck(vector&lt;int&gt;&amp; cap, int k) {
        for (auto &amp; c : cap) c--;
        int sum = accumulate(cap.begin(), cap.end(), 0);
        if (sum &lt; k) return 0;
        int dp[40005] = {1};
        for (auto &amp; c : cap) {
            for (int i = k - c; i &gt;= 0; --i) {
                (dp[i + c] += dp[i]) %= md;
            }
        }
        return dp[k];
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no434-字符串中的单词数"><a class="header" href="#no434-字符串中的单词数">No.434 字符串中的单词数</a></h1>
<p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p>
<p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> "Hello, my name is John"
<strong>输出:</strong> 5
<strong>解释: </strong>这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。
</pre>
<h1 id="思路分析"><a class="header" href="#思路分析">思路分析</a></h1>
<p>这题考察的有点像状态机。因为需要维护一个前一个字符是不是字母的状态。如果前一个是空格，后一个是字母，就说明开始了一个新单词。</p>
<h1 id="rust代码"><a class="header" href="#rust代码">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn count_segments(s: String) -&gt; i32 {
        let mut state = 0;
        let mut res = 0;
        for ch in s.chars() {
            if ch == ' ' {
                state = 0;
            } else {
                if state == 0 {
                    res += 1;
                }
                state = 1;
            }
        }
        res
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no414-第三大的数"><a class="header" href="#no414-第三大的数">No.414 第三大的数</a></h1>
<p>给你一个非空数组，返回此数组中 <strong>第三大的数</strong> 。如果不存在，则返回数组中最大的数。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>[3, 2, 1]
<strong>输出：</strong>1
<strong>解释：</strong>第三大的数是 1 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>[1, 2]
<strong>输出：</strong>2
<strong>解释：</strong>第三大的数不存在, 所以返回最大的数 2 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>[2, 2, 3, 1]
<strong>输出：</strong>1
<strong>解释：</strong>注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
<p>&nbsp;</p>
<p><strong>进阶：</strong>你能设计一个时间复杂度 <code>O(n)</code> 的解决方案吗？</p>
<h1 id="思路分析-1"><a class="header" href="#思路分析-1">思路分析</a></h1>
<p>这种题一般就套一个有序数组就行。</p>
<p>O(n)的话就维护一下有序数组，使得数组中元素的个数不会大于三个。因为大于三个也用不到。</p>
<h1 id="rust代码-1"><a class="header" href="#rust代码-1">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>use std::collections::BTreeSet;
impl Solution {
    pub fn third_max(mut nums: Vec&lt;i32&gt;) -&gt; i32 {
        let mut set = BTreeSet::new();
        for item in nums {
            set.insert(item);
        }
        *set.iter().rev().nth(2).unwrap_or(set.iter().last().unwrap())
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no284-窥探迭代器"><a class="header" href="#no284-窥探迭代器">No.284 窥探迭代器</a></h1>
<p>请你设计一个迭代器，除了支持 <code>hasNext</code> 和 <code>next</code> 操作外，还支持 <code>peek</code> 操作。</p>
<p>实现 <code>PeekingIterator</code> 类：</p>
<div class="original__bRMd">
<div>
<ul>
	<li><code>PeekingIterator(int[] nums)</code> 使用指定整数数组 <code>nums</code> 初始化迭代器。</li>
	<li><code>int next()</code> 返回数组中的下一个元素，并将指针移动到下个元素处。</li>
	<li><code>bool hasNext()</code> 如果数组中存在下一个元素，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
	<li><code>int peek()</code> 返回数组中的下一个元素，但 <strong>不</strong> 移动指针。</li>
</ul>
<p>&nbsp;</p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>
["PeekingIterator", "next", "peek", "next", "next", "hasNext"]
[[[1, 2, 3]], [], [], [], [], []]
<strong>输出：</strong>
[null, 1, 2, 2, 3, false]

<strong>解释：</strong>
PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [<em><strong>1</strong></em>,2,3]
peekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,<em><strong>2</strong></em>,3]
peekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,<em><strong>2</strong></em>,3]
peekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,<em><strong>3</strong></em>]
peekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]
peekingIterator.hasNext(); // 返回 False
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
	<li>对 <code>next</code> 和 <code>peek</code> 的调用均有效</li>
	<li><code>next</code>、<code>hasNext</code> 和 <code>peek </code>最多调用&nbsp; <code>1000</code> 次</li>
</ul>
</div>
</div>
<p>&nbsp;</p>
<p><strong>进阶：</strong>你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？</p>
<h1 id="思路分析-2"><a class="header" href="#思路分析-2">思路分析</a></h1>
<p>本题的难点主要在于，本来原题给我们提供的数据结构<code>Iterator</code>只提供了以下两个接口：</p>
<ul>
<li><code>int next()</code></li>
<li><code>bool hasNext()</code></li>
</ul>
<p>而我们要实现的数据结构要在其基础上再实现一个<code>int peek()</code>。</p>
<p>这里就会出现一个问题，也就是每次调用<code>next()</code>无疑都会使得迭代器向后移动一个位置，但是每次调用<code>peek()</code>却不会。</p>
<p>其实很好提出一个解决方法，就是在每次调用<code>next()</code>的时候拿一个数字存一下，作为下次调用<code>peek()</code>时候的返回值。但这样会出现问题。</p>
<p>观察一下示例1，可以发现，在调用<code>peek()</code>时，指针不发生移动，但是确确实实地，我们获取到了下一个变量的值。这题的难点就在于，我们期望能够在获取下一个元素的值的时候不移动指针。但<code>next()</code>一定会移动指针。</p>
<p>思路可以这样：先用一个变量一直存住下一个元素的值，如果遇到了<code>peek()</code>就返回这个预先存的值，如果遇到<code>next()</code>也返回这个预先存的值并且更新预先存的值为下一个。</p>
<h1 id="c-代码"><a class="header" href="#c-代码">C++ 代码</a></h1>
<pre><code class="language-cpp">class PeekingIterator : public Iterator {
public:
    PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) {
        flag = Iterator::hasNext();
        if (flag) {
            nextElement = Iterator::next();
        }
    }
    
    int peek() {
        return nextElement;
    }
    
    int next() {
        int ret = nextElement;
        flag = Iterator::hasNext();
        if (flag) {
            nextElement = Iterator::next();
        }
        return ret;
    }
    
    bool hasNext() const {
        return flag;
    }
private:
    int nextElement;
    bool flag;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no482-密钥格式化"><a class="header" href="#no482-密钥格式化">No.482 密钥格式化</a></h1>
<p>有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。其中， N 个 '-' 将字符串分成了 N+1 组。</p>
<p>给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。</p>
<p>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>S = "5F3Z-2e-9-w", K = 4
<strong>输出：</strong>"5F3Z-2E9W"
<strong>解释：</strong>字符串 S 被分成了两个部分，每部分 4 个字符；
&nbsp;    注意，两个额外的破折号需要删掉。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>S = "2-5g-3-J", K = 2
<strong>输出：</strong>"2-5G-3J"
<strong>解释：</strong>字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
</pre>
<p>&nbsp;</p>
<p><strong>提示:</strong></p>
<ol>
	<li>S 的长度可能很长，请按需分配大小。K 为正整数。</li>
	<li>S 只包含字母数字（a-z，A-Z，0-9）以及破折号'-'</li>
	<li>S 非空</li>
</ol>
<p>&nbsp;</p>
<h1 id="思路分析-3"><a class="header" href="#思路分析-3">思路分析</a></h1>
<p>根据题目的思路可知，原字符串中的下划线对本题没什么用，所以统计的时候去掉。</p>
<p>首先计算每个部分可以分到多少个字符，也就是parts变量。然后计算第一个区块中有多少个字符，也就是remains。如果可以整除，第一个区块中就有k个字符，如果不能整除，第一个区块中的个数会小于k个，也就是<code>valid(合法字符) / k</code>。</p>
<p>在计算完成后，就可以将原字符串中的字符填充进去。注意：在填充完成remains个之后就填入一个下划线，并且将remains重置成k，因为往后的每一个区块之内都有k个字符。</p>
<h1 id="rust代码-2"><a class="header" href="#rust代码-2">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn license_key_formatting(s: String, k: i32) -&gt; String {
        let k = k as usize;
        let n = s.len();
        let count = s.chars().fold(0, |acc, x| acc + (x == '-') as usize);
        let valid = n - count;
        let parts = valid / k + (valid % k &gt; 0) as usize;
        let mut remains = if valid % k == 0 {k} else {valid % k};
        let mut res = &quot;&quot;.to_string();
        for ch in s.chars() {
            if ch == '-' {
                continue;
            }
            if remains == 0 {
                res.push('-');
                remains = k;
            }
            res.push(ch.to_ascii_uppercase());
            remains -= 1;
        }
        res
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no166-分数到小数"><a class="header" href="#no166-分数到小数">No.166 分数到小数</a></h1>
<p>给定两个整数，分别表示分数的分子&nbsp;<code>numerator</code> 和分母 <code>denominator</code>，以 <strong>字符串形式返回小数</strong> 。</p>
<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>
<p class="MachineTrans-lang-zh-CN">如果存在多个答案，只需返回 <strong>任意一个</strong> 。</p>
<p class="MachineTrans-lang-zh-CN">对于所有给定的输入，<strong>保证</strong> 答案字符串的长度小于 <code>10<sup>4</sup></code> 。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>numerator = 1, denominator = 2
<strong>输出：</strong>"0.5"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>numerator = 2, denominator = 1
<strong>输出：</strong>"2"
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>numerator = 2, denominator = 3
<strong>输出：</strong>"0.(6)"
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>numerator = 4, denominator = 333
<strong>输出：</strong>"0.(012)"
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>numerator = 1, denominator = 5
<strong>输出：</strong>"0.2"
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>-2<sup>31</sup> &lt;=&nbsp;numerator, denominator &lt;= 2<sup>31</sup> - 1</code></li>
	<li><code>denominator != 0</code></li>
</ul>
<h1 id="思路分析-4"><a class="header" href="#思路分析-4">思路分析</a></h1>
<p>这道题本质上就是要让我们用除法的思维去做题。<br />
在我们做除法的时候，怎么判断重复循环的小数呢？</p>
<p>首先当然是进行预处理。包括以下几个步骤。</p>
<ol>
<li>处理符号，将负号统一处理一下。因为两个正数相除显然比较符合人类的习惯。</li>
<li>将所有32位数字输入处理成64位，因为可能会超限。</li>
<li>处理整数部分，因为整数部分一般不参与到循环小数的范围内。</li>
<li>其他特殊情况。</li>
</ol>
<p>在处理完上述步骤之后，我们得到了还是题目中的两个数字<code>numerator</code>和<code>denominator</code>。这两个数字仍然是被除数与除数的关系，只不过经过减去整数部分的处理之后，我们能确保<code>numerator</code>一定小于<code>denominator</code>。
<img src="2021/10/3-No.166.png" alt="小学课本对于循环小数的讲解" /></p>
<p>如果没有思路可以看一下上面这张图。这张图基本上概括了本题所需的循环小数部分的数学知识。
可以看出，在除法的过程中，遇到除不尽的数字，我们一般是采用余数的方式，并且继续拿余数乘10之后再除。可以确定的是，只有在余数出现相同的情况下，余数之后的情况也会一模一样，也就是说，第一次出现相同的余数就是循环节的位置。</p>
<p>在此处，我们使用一个哈希表来存之前出现过的所有余数，并且在第二次出现余数的时候，标注循环节的位置，结束程序。</p>
<h1 id="rust代码-3"><a class="header" href="#rust代码-3">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>use std::collections::HashMap;
impl Solution {
    pub fn fraction_to_decimal(numerator: i32, denominator: i32) -&gt; String {
        let mut ret = String::new();
        if (numerator as i64 * denominator as i64) &lt; 0 {
            ret.push('-');
        }
        let mut denominator = (denominator as i64).abs();
        let mut numerator = (numerator as i64).abs();
        let pre = numerator / denominator;
        numerator %= denominator;
        let mut map: HashMap&lt;i64, i32&gt; = HashMap::new();
        ret.push_str(&amp;pre.to_string());
        if numerator == 0 {
            return ret;
        }
        ret.push('.');
        let mut ws = ret.len() as i32;
        loop {
            if numerator == 0 {
                break;
            }
            if map.contains_key(&amp;numerator) {
                ret.insert(*map.get(&amp;numerator).unwrap() as usize, '(');
                ret.push(')');
                break;
            }
            map.insert(numerator, ws);
            numerator *= 10;
            ret.push((('0' as u8) + (numerator / denominator) as u8) as char);
            numerator %= denominator;
            ws += 1;
        }
        ret
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no405-数字转换为十六进制数"><a class="header" href="#no405-数字转换为十六进制数">No.405 数字转换为十六进制数</a></h1>
<p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用&nbsp;<a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin">补码运算</a>&nbsp;方法。</p>
<p><strong>注意:</strong></p>
<ol>
	<li>十六进制中所有字母(<code>a-f</code>)都必须是小写。</li>
	<li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符<code>'0'</code>来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。&nbsp;</li>
	<li>给定的数确保在32位有符号整数范围内。</li>
	<li><strong>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</strong></li>
</ol>
<p><strong>示例 1：</strong></p>
<pre>输入:
26

输出:
"1a"
</pre>
<p><strong>示例 2：</strong></p>
<pre>输入:
-1

输出:
"ffffffff"
</pre>
<h1 id="思路分析-5"><a class="header" href="#思路分析-5">思路分析</a></h1>
<p>本质上就是一个二进制转十六进制的操作。最好使用二进制运算来做，能够更高效地利用计算机二进制的架构。</p>
<p>一位十六进制对应到四位二进制。</p>
<h1 id="rust代码-4"><a class="header" href="#rust代码-4">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn to_hex(num: i32) -&gt; String {
        let turned: Vec&lt;char&gt; = &quot;0123456789abcdef&quot;.chars().collect();
        let mut num = num as u32;
        if num == 0 {
            return &quot;0&quot;.to_string();
        }
        let mut res = vec![];
        while num != 0 {
            let mut tmp = 0;
            for i in 0..4 {
                tmp += (num &amp; 1) * (1 &lt;&lt; i);
                num &gt;&gt;= 1;
            }
            res.push(turned[tmp as usize]);
        }
        res.reverse();
        res.iter().collect()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="c代码"><a class="header" href="#c代码">C++代码</a></h1>
<pre><code class="language-cpp">static const char * turned = &quot;0123456789abcdef&quot;;
class Solution {
public:
    string toHex(unsigned int num) {
        string res;
        do {
            int tmp = 0;
            for (int i = 0; i &lt; 4; ++i) {
                tmp += (num &amp; 1) * (1 &lt;&lt; i);
                num &gt;&gt;= 1;
            }
            res.push_back(turned[tmp]);
        } while (num != 0);
        reverse(res.begin(), res.end());
        return res;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no1436-旅行终点站"><a class="header" href="#no1436-旅行终点站">No.1436 旅行终点站</a></h1>
<p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityA<sub>i</sub>, cityB<sub>i</sub>]</code> 表示该线路将会从 <code>cityA<sub>i</sub></code> 直接前往 <code>cityB<sub>i</sub></code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
<strong>输出：</strong>"Sao Paulo" 
<strong>解释：</strong>从 "London" 出发，最后抵达终点站 "Sao Paulo" 。本次旅行的路线是 "London" -&gt; "New York" -&gt; "Lima" -&gt; "Sao Paulo" 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>paths = [["B","C"],["D","B"],["C","A"]]
<strong>输出：</strong>"A"
<strong>解释：</strong>所有可能的线路是：
"D" -&gt; "B" -&gt; "C" -&gt; "A".&nbsp;
"B" -&gt; "C" -&gt; "A".&nbsp;
"C" -&gt; "A".&nbsp;
"A".&nbsp;
显然，旅行终点站是 "A" 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>paths = [["A","Z"]]
<strong>输出：</strong>"Z"
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>1 &lt;= paths.length &lt;= 100</code></li>
	<li><code>paths[i].length == 2</code></li>
	<li><code>1 &lt;=&nbsp;cityA<sub>i</sub>.length,&nbsp;cityB<sub>i</sub>.length &lt;= 10</code></li>
	<li><code>cityA<sub>i&nbsp;</sub>!=&nbsp;cityB<sub>i</sub></code></li>
	<li>所有字符串均由大小写英文字母和空格字符组成。</li>
</ul>
<h1 id="思路分析-6"><a class="header" href="#思路分析-6">思路分析</a></h1>
<p>如题要求一个站点没有下一个到达点，也就是说该城市不会位于(A, B)中的A位置，只位于B位置，因此我们只需要将所有的A用哈希表存储起来，然后遍历所有B，查看是否存在于表中，某个城市不存在直接返回答案（该城市）。</p>
<h1 id="java代码"><a class="header" href="#java代码">Java代码</a></h1>
<pre><code class="language-java">class Solution {
    public String destCity(List&lt;List&lt;String&gt;&gt; paths) {
        int len = paths.size();
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        paths.forEach((path) -&gt; {
            set.add(path.get(0));
        });
        for (int i = 0; i &lt; len; i++) {
            List&lt;String&gt; list = paths.get(i);
            if (!set.contains(list.get(1))) {
                return list.get(1);
            }
        }
        return null;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no223-矩形面积"><a class="header" href="#no223-矩形面积">No.223 矩形面积</a></h1>
<p>给你 <strong>二维</strong> 平面上两个 <strong>由直线构成的</strong> 矩形，请你计算并返回两个矩形覆盖的总面积。</p>
<p>每个矩形由其 <strong>左下</strong> 顶点和 <strong>右上</strong> 顶点坐标表示：</p>
<div class="MachineTrans-Lines">
<ul>
	<li class="MachineTrans-lang-zh-CN">第一个矩形由其左下顶点 <code>(ax1, ay1)</code> 和右上顶点 <code>(ax2, ay2)</code> 定义。</li>
	<li class="MachineTrans-lang-zh-CN">第二个矩形由其左下顶点 <code>(bx1, by1)</code> 和右上顶点 <code>(bx2, by2)</code> 定义。</li>
</ul>
</div>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<img style="width: 700px; height: 365px;" src="https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png" alt="Rectangle Area">
<pre><strong>输入：</strong>ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2
<strong>输出：</strong>45
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2
<strong>输出：</strong>16
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>-10<sup>4</sup> &lt;= ax1, ay1, ax2, ay2, bx1, by1, bx2, by2 &lt;= 10<sup>4</sup></code></li>
</ul>
<hr />
<h1 id="思路分析-7"><a class="header" href="#思路分析-7">思路分析</a></h1>
<p>首先可以想想，两个长方形重叠有哪些情况，有如上图这样，也有这样：</p>
<p><img src="https://img-blog.csdnimg.cn/1b8334a2206c443aa156f9d53637ea3e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55-t6IW_Q2F0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="msg" /></p>
<p>也有如下这样：<br />
<img src="https://img-blog.csdnimg.cn/ac7193b3081f4082a2e83f86184d473a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55-t6IW_Q2F0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="msg2" /></p>
<p>也有可能长这样：<br />
<img src="https://img-blog.csdnimg.cn/18e4009dfa5744448495a7c6ae34fba1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55-t6IW_Q2F0,size_17,color_FFFFFF,t_70,g_se,x_16" alt="msg3" /></p>
<p>但其实不管他到底长什么样，我们都可以通过两正方形面积之和减去重合部分得出答案，设两长方形分别为 A 和 B，则：<br />
<img src="https://img-blog.csdnimg.cn/10f1131f3f974fc2a05a5db0ffb069f3.png" alt="公式" /></p>
<p>A 和 B 的面积很好求，这里就不再赘述，这里主要说说重合的面积如何求；
重合部分仔细考虑，他也是一个长方形，也有长和高，所以求出长和高是关键：
长为 x 轴方向某两个端点之差，高则是 y 轴方向某两个端点之差，那这两个点是哪两个呢？</p>
<p>是这两个点（这种情况是红色部分点减去绿色部分点，为正数）：<br />
<img src="https://img-blog.csdnimg.cn/7fc1096eb8594b4f95f51d33caf27a5f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55-t6IW_Q2F0,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>是这两个点（这种情况是绿色点减去黄色点，为负数）：<br />
<img src="https://img-blog.csdnimg.cn/a094c0abf4ed4680b90aed34ba6012ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55-t6IW_Q2F0,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>由此可见：两点分别为：<strong>两个长方形的最右边的 x 的最小值</strong> &amp; <strong>两个长方形最左边的 x 的最大值</strong></p>
<p>高度方向也类似，就不过于赘述。</p>
<p>若长或者高任一为负数 or0，则将其置为 0.得出的重合面积也为 0：</p>
<h1 id="java-代码"><a class="header" href="#java-代码">Java 代码</a></h1>
<pre><code class="language-java">class Solution {
    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        int A = (ax1 - ax2) * (ay1 - ay2);
        int B = (bx1 - bx2) * (by1 - by2);
        int C_X = Math.max(0, Math.min(ax2 ,bx2) - Math.max(ax1, bx1));
        int C_Y = Math.max(0, Math.min(ay2 ,by2) - Math.max(ay1, by1));
        int C = C_X * C_Y;
        return A + B - C;
    }
}
</code></pre>
<h1 id="rust-代码"><a class="header" href="#rust-代码">Rust 代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>pub fn compute(a: i32, b: i32, c: i32, d: i32) -&gt; i32 {
    let t = c.max(a);
    (b - t).min(d - t).max(0)
}
impl Solution {
    pub fn compute_area(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, g: i32, h: i32) -&gt; i32 {
        // 重叠面积
        let cd = compute(a, c, e, g) * compute(b, d, f, h);
        (c-a)*(d-b) + (h-f)*(g-e) - cd
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no517-超级洗衣机"><a class="header" href="#no517-超级洗衣机">No.517 超级洗衣机</a></h1>
<p>假设有 <code>n</code><strong>&nbsp;</strong>台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。</p>
<p>在每一步操作中，你可以选择任意 <code>m</code> (<code>1 &lt;= m &lt;= n</code>) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。</p>
<p>给定一个整数数组&nbsp;<code>machines</code> 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 <strong>最少的操作步数 </strong>。如果不能使每台洗衣机中衣物的数量相等，则返回 <code>-1</code> 。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>machines = [1,0,5]
<strong>输出：</strong>3
<strong>解释：</strong>
第一步:    1     0 &lt;-- 5    =&gt;    1     1     4
第二步:    1 &lt;-- 1 &lt;-- 4    =&gt;    2     1     3    
第三步:    2     1 &lt;-- 3    =&gt;    2     2     2   
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>machines = [0,3,0]
<strong>输出：</strong>2
<strong>解释：</strong>
第一步:    0 &lt;-- 3     0    =&gt;    1     2     0    
第二步:    1     2 --&gt; 0    =&gt;    1     1     1     
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>machines = [0,2,0]
<strong>输出：</strong>-1
<strong>解释：</strong>
不可能让所有三个洗衣机同时剩下相同数量的衣物。
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>n == machines.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= machines[i] &lt;= 10<sup>5</sup></code></li>
</ul>
<h1 id="思路分析-8"><a class="header" href="#思路分析-8">思路分析</a></h1>
<p>本题主要的思路就是遍历。
先遍历一遍，求得是否有可行解以及每个位置上的平均衣服的件数<code>avg</code>是多少。
这里肯定大家都想得到。那么下面怎么办呢？
我们知道，如果衣服多，假设一个位置上有<code>K</code>件衣服，而<code>K&gt;avg</code>,那么我们最终的答案一定不会小于<code>K-avg</code>，因为对于该堆衣服来说，不考虑其他洗衣机的操作，仅对于本洗衣机而言，一定要花费<code>K-avg</code>的时间将里面多出来的衣服分出去。</p>
<p>对于本题我们还知道，可以在遍历数组的时候维护一个<code>cur</code>。假设有一只无形的大手在遍历数组的同时将所有洗衣机里衣服的数量变成了<code>avg</code>，多余的衣服就认为是余量，缺少的就认为是缺口。这样有一个好处，就是能够各司其职。下面的例子能够加强理解。</p>
<pre><code class="language-json">示例：          [5, 0, 7], avg = 12 / 3 = 4
在遍历时的`cur`值：[1, -3, 0]
</code></pre>
<p>这样可以发现，对于本数组而言，<code>cur</code>的最大绝对值就是需要的总时间。因为我们如果单看一个1号位，也就是中间的那一位，我们会发现，一定要4次填充才能将其填到<code>avg</code>。但是这四次填充有一次是来自左边，三次是来自右边，这两段时间是可以重叠的。而<code>cur</code>值就很好的对于缺口和余量的体现。当遍历到这一位，缺口是k时，说明之前的所有洗衣机就算内部匀一匀也还缺k个，必须从<code>cur</code>的右方去移动过来，这个k就是最小移动时间。而当余量是k时，也是一样的道理，说明在<code>cur</code>及<code>cur</code>的左边怎么匀都会多出来k个，必须转移到<code>cur</code>的右边，而转移必须通过<code>cur</code>，也就是说这k个转移是没有叠加的余地的，必须在最短为k的时间内完成。</p>
<p>所以<code>cur</code>可以作为一个全局的转移次数的把控。但还存在一些局限。看下面一个例子</p>
<pre><code class="language-json">示例：          [0, 3, 0], avg = 3 / 3 = 1
在遍历时的`cur`值：[-1, 1, 0]
</code></pre>
<p>这个示例来看，<code>cur</code>忽略了一个非常关键的点，也就是对于3而言，必须花费2次的时间才能将其完全转移出去。但对于<code>cur</code>来说，它并不知道自己所遍历到的-1和1是没法叠加的，都是从3上面分出来的。那么这时候就需要同考虑<code>cur</code>和<code>K-avg</code>对于最终结果的作用了。</p>
<h1 id="rust代码-5"><a class="header" href="#rust代码-5">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn find_min_moves(machines: Vec&lt;i32&gt;) -&gt; i32 {
        let sum: i32 = machines.iter().sum();
        let n = machines.len() as i32;
        if sum % n != 0 {
            return -1;
        } 
        let avg = sum / n;
        let mut res = 0;
        let mut cur = 0;
        for mut m in machines {
            m -= avg;
            cur += m;
            res = res.max(cur.abs()).max(m);
        }
        res
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="c代码-1"><a class="header" href="#c代码-1">C++代码</a></h1>
<pre><code class="language-cpp">class Solution {
public:
    int findMinMoves(vector&lt;int&gt;&amp; m) {
        int n = m.size();
        int sum = 0;
        for (auto &amp; t : m) sum += t;
        if (sum % n != 0) return -1;
        int per = sum / n;
        sum = 0;
        int res = 0;
        for (auto &amp; t : m) {
            t -= per;
            sum += t;
            res = max(res, abs(sum));
            res = max(res, t);
        }
        return res;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no437-路径总和-iii"><a class="header" href="#no437-路径总和-iii">No.437 路径总和 III</a></h1>
<p>给定一个二叉树的根节点 <code>root</code>&nbsp;，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<p><img style="width: 452px;" src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg"></p>
<pre><strong>输入：</strong>root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
<strong>输出：</strong>3
<strong>解释：</strong>和等于 8 的路径有 3 条，如图所示。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
<strong>输出：</strong>3
</pre>
<p>&nbsp;</p>
<p><strong>提示:</strong></p>
<ul>
	<li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>
	<li><code>-10<sup>9</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>9</sup></code>&nbsp;</li>
	<li><code>-1000&nbsp;&lt;= targetSum&nbsp;&lt;= 1000</code>&nbsp;</li>
</ul>
<h1 id="思路分析-9"><a class="header" href="#思路分析-9">思路分析</a></h1>
<p>不难看出本题一定会遍历到每个节点。而且方式一定是dfs。因为只有dfs我们才比较方便对路径进行处理。<br />
常规的思路一定是存一下本节点之前遍历到的路径的所有值。并且回溯删除来保证只关注遍历到的节点所处的环境。</p>
<p>但是这样会比较复杂，如果只存之前遍历到的所有值，我们还得判断哪些区间可以加起来等于target。这样就是<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>所以我们尝试用前缀和来简化一下，也就是在数组中存之前遍历到的所有从根节点开始的路径总和。<br />
若一条路径上的节点为<code>[1,2,3,4]</code>
我们用前缀和存储变成<code>[1,3,6,10]</code>
当我们遍历到值为4的节点的时候，此时从根节点到本节点的路径总和是10，假设target是7，我们只需要找出来在前缀和数组中 值等于<code>10-7</code>也就是<code>3</code>的节点即可算作有效方案，此时复杂度为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，因为需要对前缀和数组进行一次遍历。</p>
<p>本方案还可以进一步优化，因为我们要在数组里查找，而且是指定值去查找，就可以用哈希表来优化一下，最终查找的操作复杂度被我们从<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>降低到了<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h1 id="c代码-2"><a class="header" href="#c代码-2">C++代码</a></h1>
<pre><code class="language-cpp">class Solution {
public:
    int res = 0, tar;
    unordered_map&lt;int, int&gt; v;
    void dfs(TreeNode * root, int cur) {
        if (!root) return;
        int tmp = cur + root-&gt;val;
        res += v[tmp - tar];
        v[tmp]++; 
        dfs(root-&gt;left, tmp);
        dfs(root-&gt;right, tmp);
        v[tmp]--; // 回溯删除
    }
    int pathSum(TreeNode* root, int targetSum) {
        tar = targetSum;
        v[0] = 1;
        dfs(root, 0);
        return res;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no639-解码方法-ii"><a class="header" href="#no639-解码方法-ii">No.639 解码方法 II</a></h1>
<p>一条包含字母&nbsp;<code>A-Z</code> 的消息通过以下的方式进行了编码：</p>
<pre>'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
</pre>
<p>要 <strong>解码</strong> 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，<code>"11106"</code> 可以映射为：</p>
<ul>
	<li><code>"AAJF"</code> 对应分组 <code>(1 1 10 6)</code></li>
	<li><code>"KJF"</code> 对应分组 <code>(11 10 6)</code></li>
</ul>
<p>注意，像 <code>(1 11 06)</code> 这样的分组是无效的，因为 <code>"06"</code> 不可以映射为 <code>'F'</code> ，因为 <code>"6"</code> 与 <code>"06"</code> 不同。</p>
<p><strong>除了</strong> 上面描述的数字字母映射方案，编码消息中可能包含 <code>'*'</code> 字符，可以表示从 <code>'1'</code> 到 <code>'9'</code> 的任一数字（不包括 <code>'0'</code>）。例如，编码字符串 <code>"1*"</code> 可以表示 <code>"11"</code>、<code>"12"</code>、<code>"13"</code>、<code>"14"</code>、<code>"15"</code>、<code>"16"</code>、<code>"17"</code>、<code>"18"</code> 或 <code>"19"</code> 中的任意一条消息。对 <code>"1*"</code> 进行解码，相当于解码该字符串可以表示的任何编码消息。</p>
<p>给你一个字符串 <code>s</code> ，由数字和 <code>'*'</code> 字符组成，返回 <strong>解码</strong> 该字符串的方法 <strong>数目</strong> 。</p>
<p>由于答案数目可能非常大，返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "*"
<strong>输出：</strong>9
<strong>解释：</strong>这一条编码消息可以表示 "1"、"2"、"3"、"4"、"5"、"6"、"7"、"8" 或 "9" 中的任意一条。
可以分别解码成字符串 "A"、"B"、"C"、"D"、"E"、"F"、"G"、"H" 和 "I" 。
因此，"*" 总共有 9 种解码方法。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "1*"
<strong>输出：</strong>18
<strong>解释：</strong>这一条编码消息可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条。
每种消息都可以由 2 种方法解码（例如，"11" 可以解码成 "AA" 或 "K"）。
因此，"1*" 共有 9 * 2 = 18 种解码方法。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "2*"
<strong>输出：</strong>15
<strong>解释：</strong>这一条编码消息可以表示 "21"、"22"、"23"、"24"、"25"、"26"、"27"、"28" 或 "29" 中的任意一条。
"21"、"22"、"23"、"24"、"25" 和 "26" 由 2 种解码方法，但 "27"、"28" 和 "29" 仅有 1 种解码方法。
因此，"2*" 共有 (6 * 2) + (3 * 1) = 12 + 3 = 15 种解码方法。
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> 是 <code>0 - 9</code> 中的一位数字或字符 <code>'*'</code></li>
</ul>
<h1 id="思路分析-10"><a class="header" href="#思路分析-10">思路分析</a></h1>
<p>这一题考察的主要就是思路严密。<br />
通过题目所给信息不难判断这是一个一维的动态规划。<br />
思路也是非常动态规划，dp[i]为使用了s的前i个字符所有的方案数。</p>
<ul>
<li>如果s[i] 不是 '0'，那么就说明可以单独作为一个方案。也就是 dp[i + 1] += dp[i]</li>
<li>如果s[i - 1]和s[i]可以组成大于等于<strong>10</strong>（此处应为大坑，因为不能出现&quot;01&quot;）且小于等于26的数字，那么我们就认为可以将这两位数作为一个方案。dp[i + 1] += dp[i - 1]</li>
</ul>
<p>思路非常简单，但是实现比较复杂，是因为我们总是会忽略各种各样的情况，比如&quot;*&quot;只能代表1到9，&quot;01&quot;不能作为合法的数之类的。</p>
<p>主要的思路就是分开来写，对于s[i]和s[i-1]是不是&quot;*&quot;分四种情况讨论，这样就不会漏了。</p>
<h1 id="c代码-3"><a class="header" href="#c代码-3">C++代码</a></h1>
<pre><code class="language-cpp">using ll = int64_t;
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        ll dp[n + 1];
        memset(dp, 0, sizeof dp);
        dp[0] = 1;
        for (int i = 0; i &lt; n; ++i) {
            if (s[i] == '*') dp[i + 1] += dp[i] * 9;
            else if (s[i] != '0') dp[i + 1] += dp[i];
            if (i &gt; 0) {
// cout &lt;&lt; &quot;Good&quot;;
                if (s[i - 1] == '*' &amp;&amp; s[i] != '*'){
                    if (s[i] &lt;= '6') dp[i + 1] += 2 * dp[i - 1];
                    else dp[i + 1] += dp[i - 1];
                } else if (s[i - 1] == '*' &amp;&amp; s[i] == '*') {
                    // cout &lt;&lt; &quot;Good&quot;;
                    dp[i + 1] += dp[i - 1] * 15;
                } else if (s[i - 1] != '*' &amp;&amp; s[i] == '*') {
                    if (s[i - 1] == '1') dp[i + 1] += dp[i - 1] * 9;
                    else if (s[i - 1] == '2') dp[i + 1] += dp[i - 1] * 6;
                } else {
                    if (s[i - 1] == '1' || (s[i - 1] == '2' &amp;&amp; s[i] &lt;= '6'))
                        dp[i + 1] += dp[i - 1];
                }
            }
            dp[i + 1] %= ll(1e9 + 7);
        }
        return dp[n];
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no371-两整数之和"><a class="header" href="#no371-两整数之和">No.371 两整数之和</a></h1>
<p>给你两个整数 <code>a</code> 和 <code>b</code> ，<strong>不使用 </strong>运算符&nbsp;<code>+</code> 和&nbsp;<code>-</code>&nbsp;​​​​​​​，计算并返回两整数之和。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>a = 1, b = 2
<strong>输出：</strong>3
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>a = 2, b = 3
<strong>输出：</strong>5
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>-1000 &lt;= a, b &lt;= 1000</code></li>
</ul>
<h1 id="思路分析-11"><a class="header" href="#思路分析-11">思路分析</a></h1>
<p>先给大家讲一下什么是加法器。
加法器，顾名思义，就是做加法运算的工具。一个二输入的二进制加法器，应该有两个输出，一个是原原，一个是进位。
下面给大家打个表看看。</p>
<table><thead><tr><th>数1</th><th>数2</th><th>答案</th><th>原位</th><th>进位</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>10</td><td>0</td><td>1</td></tr>
</tbody></table>
<p>观察上表，我们不难看出，由原位和进位组成了最终的答案。
而原位操作对于二进制来说就是一个很明显的异或(XOR)操作，而进位操作也就是与(AND)操作。那么我们可以得到一个等式：</p>
<ul>
<li>a + b = a ^ b + (a &amp; b) * 2</li>
<li>也就是</li>
<li>a + b = a ^ b + (a &amp; b) &lt;&lt; 1</li>
</ul>
<p>从一个加号变成了另一个加号！好像没啥用。
但遇到这种情况，我们可以考虑，是否可以递归。
观察可得，a &amp; b一定是一个越来越小的数字，它最后一定会趋向于0。一旦b趋向于0，那么答案就是a，我们就有了递归的基础。</p>
<h1 id="rust代码-6"><a class="header" href="#rust代码-6">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn get_sum(a: i32, b: i32) -&gt; i32 {
        if b == 0 {
            a
        } else {
            Solution::get_sum(a ^ b, (a &amp; b) &lt;&lt; 1)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="c代码-4"><a class="header" href="#c代码-4">C++代码</a></h1>
<pre><code class="language-cpp">class Solution {
public:
    unsigned getSum(unsigned a, unsigned b) {
        if (b == 0) return a;
        return getSum(a ^ b, (a &amp; b) &lt;&lt; 1);
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no583-两个字符串的删除操作"><a class="header" href="#no583-两个字符串的删除操作">No.583 两个字符串的删除操作</a></h1>
<p>给定两个单词&nbsp;<em>word1&nbsp;</em>和&nbsp;<em>word2</em>，找到使得&nbsp;<em>word1&nbsp;</em>和&nbsp;<em>word2&nbsp;</em>相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>&nbsp;</p>
<p><strong>示例：</strong></p>
<pre><strong>输入:</strong> "sea", "eat"
<strong>输出:</strong> 2
<strong>解释:</strong> 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ol>
	<li>给定单词的长度不超过500。</li>
	<li>给定单词中的字符只含有小写字母。</li>
</ol>
<h1 id="思路分析-12"><a class="header" href="#思路分析-12">思路分析</a></h1>
<p>两个字符串求这种类似编辑距离的题基本上用二维动态规划都比较简单。
这道题有两种思路（均为动态规划），一种正着想，一种倒着想。</p>
<h2 id="正向思维"><a class="header" href="#正向思维">正向思维</a></h2>
<p><code>dp[i][j]</code>表示答案，也就是<code>word1</code>中前<code>i</code>个字符和<code>word2</code>中前<code>j</code>个字符所组成的字符串的删除操作的最短步数。<br />
那么边界条件首先是<code>dp[i][0]=i(i &lt;= word1.length)</code>与<code>dp[0][i]=i(i &lt;= word2.length)</code>。因为一个空字符串与一个长度为<code>i</code>的字符串，总是要把长度为<code>i</code>的字符串删空才能相等，所以边界条件就此确定。
动态规划的转移方程为两个</p>
<ul>
<li><code>dp[i + 1][j + 1] = dp[i][j] (a[i] == b[j])</code></li>
<li><code>dp[i + 1][j + 1] = min(dp[i + 1][j], dp[i][j + 1]) + 1 (a[i] != b[i])</code></li>
</ul>
<p>第一行，相等的时候，因为当出现两个相等字符的时候，删除的距离一定不增加。
第二行也很好理解，如果没法做到相同的字符，那么就只能在删掉一位的基础上再进行比较，那么会在取最小值之后再加上1。</p>
<h2 id="逆向思维"><a class="header" href="#逆向思维">逆向思维</a></h2>
<p>既然是删除字符串中的某些字符，那么留下来的公共部分我们怎么称呼呢？仔细思考，便发现，这不就是<strong>最长公共子序列</strong>吗！<br />
那么我们就可以先求出两个字符串最长公共子序列的长度，然后再用两个字符串的长度减去最长公共子序列两倍的长度，即可获得每边字符串需要减少的字符数量之和。
边界条件<code>dp[i][0]=0</code>与<code>dp[0][i]=0</code><br />
动态规划的转移方程</p>
<ul>
<li><code>dp[i + 1][j + 1] = dp[i][j] + 1 (a[i] == b[j])</code></li>
<li><code>dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) (a[i] != b[i])</code></li>
</ul>
<p>也比较好理解。</p>
<h1 id="c代码正向"><a class="header" href="#c代码正向">C++代码（正向）</a></h1>
<pre><code class="language-cpp">#define REP(i, j) for (int i = 0; i &lt; j; ++i)
class Solution {
public:
    int minDistance(string a, string b) {
        int m = a.size(), n = b.size();
        int dp[m + 1][n + 1];
        memset(dp, 0, sizeof dp);
        REP(i, m) REP(j, n)
            if (a[i] == b[j]) dp[i + 1][j + 1] = dp[i][j] + 1;
            else dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]);
        return m + n - 2 * dp[m][n];
    }
};
</code></pre>
<h2 id="c代码逆向"><a class="header" href="#c代码逆向">C++代码（逆向）</a></h2>
<pre><code class="language-cpp">#define REP(i, j) for (int i = 0; i &lt; j; ++i)
class Solution {
public:
    int minDistance(string a, string b) {
        /*这破烂玩意不用dp做我把力扣炸了*/
        int m = a.size(), n = b.size();
        int dp[m + 1][n + 1];
        memset(dp, 0, sizeof dp);
        REP(i, m) REP(j, n)
            if (a[i] == b[j]) dp[i + 1][j + 1] = dp[i][j] + 1;
            else dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]);
        return m + n - 2 * dp[m][n];
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no430-扁平化多级双向链表"><a class="header" href="#no430-扁平化多级双向链表">No.430 扁平化多级双向链表</a></h1>
<p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
<strong>输出：</strong>[1,2,3,7,8,11,12,9,10,4,5,6]
<strong>解释：
</strong>
输入的多级列表如下图所示：

<img style="height: 363px; width: 640px;" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png">

扁平化后的链表如下图：

<img style="height: 80px; width: 1100px;" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png">
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>head = [1,2,null,3]
<strong>输出：</strong>[1,3,2]
<strong>解释：

</strong>输入的多级列表如下图所示：

  1---2---NULL
  |
  3---NULL
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>head = []
<strong>输出：</strong>[]
</pre>
<p>&nbsp;</p>
<p><strong>如何表示测试用例中的多级链表？</strong></p>
<p>以 <strong>示例 1</strong> 为例：</p>
<pre> 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL</pre>
<p>序列化其中的每一级之后：</p>
<pre>[1,2,3,4,5,6,null]
[7,8,9,10,null]
[11,12,null]
</pre>
<p>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p>
<pre>[1,2,3,4,5,6,null]
[null,null,7,8,9,10,null]
[null,11,12,null]
</pre>
<p>合并所有序列化结果，并去除末尾的 null 。</p>
<pre>[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li>节点数目不超过 1000</li>
	<li><code>1 &lt;= Node.val &lt;= 10^5</code></li>
</ul>
<h1 id="思路及代码分析"><a class="header" href="#思路及代码分析">思路及代码分析</a></h1>
<p>这种题目一看就可以拿递归做。而且递归是一个比较直观的办法。
我们拿第一个示例来看，假设我们遍历到了3这个节点，而它有child，我们需要获取的其实是child的最后一个节点。有了最后一个节点，我们才能将其与3的后一个节点4进行连接，部分插入。</p>
<p>按照这个思想，我们必须新建一个函数去完成这项工作，因为原函数给入的是头结点，返回的也是头结点，而我们自定义的函数给入的头结点，返回的是尾节点。</p>
<p>首先先用简单的方法来思考，假设链表里没有child。
那么我们的函数差不多长这样：</p>
<pre><code class="language-cpp">class Solution {
public:
    Node * deal(Node * node) {
        // 该函数返回处理之后的尾节点
        if (!node) return node;
        Node * nxt = node-&gt;next;
        if (!nxt) return node;
        else return deal(nxt);
    }
    Node* flatten(Node* head) {
        deal(head);
        return head;
    }
}
</code></pre>
<p>该函数<code>deal</code>能够确保返回一个链表（不考虑child节点）的最后一个元素。</p>
<p>那么考虑完了没有child节点的情况，再来想一下初衷，为什么要获取一个链表的尾节点呢？很明显就是因为，child对于我们来说是一个插入的操作，不懂的可以看第一个示例和答案，也就是说，如果一个节点有child节点，那么就相当于要将child节点插入到本节点和本节点的next节点之间。因为这是双向链表，所以我们必须拿到四个关键节点（也就是本节点、本节点的next节点，child的头结点、child的尾节点）才能进行后续工作。其中前三个都很好获取，直接取就行，但是child的尾节点对我们来说不是很容易获得，所以我们就用deal来递归获取。</p>
<p>在<code>deal(child-&gt;next)</code>获取到child的尾指针之后，就进行拼接的工作，当然我们可以进行一个边界的判断，如果该指针本身就是一个尾指针，也就是说，如果该指针next为空，child非空，我们就可以将child直接接到该指针后面，而无需进行child尾部连接的工作。</p>
<h1 id="c代码-5"><a class="header" href="#c代码-5">C++代码</a></h1>
<pre><code class="language-cpp">class Solution {
public:
    Node * deal(Node * node) {
        if (!node) return node;
        Node * nxt = node-&gt;next;
        if (node-&gt;child) {
            Node * cd = node-&gt;child;
            node-&gt;child = nullptr;
            node-&gt;next = cd;
            cd-&gt;prev = node;
            if (!nxt) {
                return deal(node-&gt;next);
            } else {
                Node * tail = deal(cd);
                tail-&gt;next = nxt;
                tail-&gt;next-&gt;prev = tail;
            }
            
        }
        if (!nxt) return node;
        else return deal(nxt);
    }
    Node* flatten(Node* head) {
        deal(head);
        return head;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no326-3的幂"><a class="header" href="#no326-3的幂">No.326 3的幂</a></h1>
<p>给定一个整数，写一个函数来判断它是否是 3&nbsp;的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>整数 <code>n</code> 是 3 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 3<sup>x</sup></code></p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 27
<strong>输出：</strong>true
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 0
<strong>输出：</strong>false
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 9
<strong>输出：</strong>true
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>n = 45
<strong>输出：</strong>false
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
<p>&nbsp;</p>
<p><strong>进阶：</strong></p>
<ul>
	<li>你能不使用循环或者递归来完成本题吗？</li>
</ul>
<h1 id="思路分析-13"><a class="header" href="#思路分析-13">思路分析</a></h1>
<p>这题其实很简单，不管递归与否</p>
<p>递归就是常规想法，一直除3，如果除得只剩下1，那么就是3的幂次，如果还剩点别的就不是。</p>
<p>非递归也是常规想法，幂次有一个特性，就是它的因子包含比它更小（或者相等）的3的所有幂次。所以我们只需要选出来一个可能出现的最大的3的幂次N（在32位整数条件下为1162261467），判断给入的数字是否是N的因子，如果是，那么一定是3的幂次。</p>
<h1 id="rust代码-7"><a class="header" href="#rust代码-7">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn is_power_of_three(n: i32) -&gt; bool {
        if n % 3 == 0 &amp;&amp; n != 0 {
            Self::is_power_of_three(n / 3)
        } else {
            n == 1
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="c代码-6"><a class="header" href="#c代码-6">C++代码</a></h1>
<pre><code class="language-cpp">class Solution {
public:
    bool isPowerOfThree(int n) {
        return n &gt; 0 &amp;&amp; 1162261467 % n == 0;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no725-分隔链表"><a class="header" href="#no725-分隔链表">No.725 分隔链表</a></h1>
<p>给你一个头结点为 <code>head</code> 的单链表和一个整数 <code>k</code> ，请你设计一个算法将链表分隔为 <code>k</code> 个连续的部分。</p>
<p>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。</p>
<p>这 <code>k</code> 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。</p>
<p>返回一个由上述 <code>k</code> 部分组成的数组。</p>
&nbsp;
<p><strong>示例 1：</strong></p>
<img style="width: 400px; height: 134px;" src="https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg" alt="">
<pre><strong>输入：</strong>head = [1,2,3], k = 5
<strong>输出：</strong>[[1],[2],[3],[],[]]
<strong>解释：</strong>
第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。
最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。
</pre>
<p><strong>示例 2：</strong></p>
<img style="width: 600px; height: 60px;" src="https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg" alt="">
<pre><strong>输入：</strong>head = [1,2,3,4,5,6,7,8,9,10], k = 3
<strong>输出：</strong>[[1,2,3,4],[5,6,7],[8,9,10]]
<strong>解释：</strong>
输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li>链表中节点的数目在范围 <code>[0, 1000]</code></li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
	<li><code>1 &lt;= k &lt;= 50</code></li>
</ul>
<h1 id="思路分析-14"><a class="header" href="#思路分析-14">思路分析</a></h1>
<p>首先是肯定要获取链表的长度。毕竟这是一个划分链表的题目，要均分成<code>k</code>份，如果不知道链表的长度，肯定没法划分，所以必须得先遍历一遍获得链表的长度<code>len</code>。</p>
<p>在获取了<code>len</code>之后，必须
在获取长度之后，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.01968em;">tl</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，这一句话的意思就是均分长度，但不考虑多余的部分，比如长度为10的分成3份，每一份的基础长度是3，余1，多出来的这个1加到了其中的一个3上，就变成了<code>[4,3,3]</code>这样的形式。余数在代码中就是<code>remains</code>这个变量。</p>
<p>然后思路就很明确了，为了方便实现了一个划分函数，干两件事，划分链表，返回划分后的链表和划分出来的部分链表。
一个示例：原链表head是<code>[1,2,3,4,5]</code>， <code>cut(head,3)</code>之后返回<code>[1,2,3]</code>并且head变成了<code>[4,5]</code>。这么处理会在最终形成答案的时候比较方便。
最后还要特判一下为空指针的情况，否则可能会出现错误。</p>
<h1 id="c代码-7"><a class="header" href="#c代码-7">C++代码</a></h1>
<pre><code class="language-cpp">class Solution {
public:
    ListNode * cut(ListNode *&amp; node, int cutlen) {
        ListNode * res = node;
        for (int i = 0; i &lt; cutlen - 1; ++i) node = node-&gt;next;
        ListNode * hold = node;
        node = node-&gt;next;
        hold-&gt;next = nullptr;
        return res;
    }
    vector&lt;ListNode*&gt; splitListToParts(ListNode* head, int k) {
        if (!head) return vector&lt;ListNode *&gt;(k, nullptr);
        ListNode * cur = head;
        int len = 0;
        while (cur) {
            cur = cur-&gt;next;
            len++;
        }
        int partlen = len / k, remains = len - k * partlen, i = 0;
        vector&lt;ListNode *&gt; res(k);
        for (; i &lt; remains; ++i) res[i] = cut(head, partlen + 1);
        for (; i &lt; k; ++i) if (partlen) res[i] = cut(head, partlen);
        return res;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no1583-统计不开心的朋友"><a class="header" href="#no1583-统计不开心的朋友">No.1583 统计不开心的朋友</a></h1>
<p>给你一份 <code>n</code> 位朋友的亲近程度列表，其中 <code>n</code> 总是 <strong>偶数</strong> 。</p>
<p>对每位朋友 <code>i</code>，<code>preferences[i]</code> 包含一份 <strong>按亲近程度从高</strong><strong>到低排列</strong> 的朋友列表。换句话说，排在列表前面的朋友与 <code>i</code> 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 <code>0</code> 到 <code>n-1</code> 之间的整数表示。</p>
<p>所有的朋友被分成几对，配对情况以列表 <code>pairs</code> 给出，其中 <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 <code>x<sub>i</sub></code> 与 <code>y<sub>i</sub></code> 配对，且 <code>y<sub>i</sub></code> 与 <code>x<sub>i</sub></code> 配对。</p>
<p>但是，这样的配对情况可能会是其中部分朋友感到不开心。在 <code>x</code> 与 <code>y</code> 配对且 <code>u</code> 与 <code>v</code> 配对的情况下，如果同时满足下述两个条件，<code>x</code> 就会不开心：</p>
<ul>
	<li><code>x</code> 与 <code>u</code> 的亲近程度胜过 <code>x</code> 与 <code>y</code>，且</li>
	<li><code>u</code> 与 <code>x</code> 的亲近程度胜过 <code>u</code> 与 <code>v</code></li>
</ul>
<p>返回 <strong>不开心的朋友的数目</strong> 。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]
<strong>输出：</strong>2
<strong>解释：</strong>
朋友 1 不开心，因为：
- <strong>1 与 0 </strong>配对，但 <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高，且
- <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高。
朋友 3 不开心，因为：
- 3 与 2 配对，但 <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高，且
- <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高。
朋友 0 和 2 都是开心的。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2, preferences = [[1], [0]], pairs = [[1, 0]]
<strong>输出：</strong>0
<strong>解释：</strong>朋友 0 和 1 都开心。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]
<strong>输出：</strong>4
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>2 &lt;= n &lt;= 500</code></li>
	<li><code>n</code> 是偶数</li>
	<li><code>preferences.length&nbsp;== n</code></li>
	<li><code>preferences[i].length&nbsp;== n - 1</code></li>
	<li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li>
	<li><code>preferences[i]</code> 不包含 <code>i</code></li>
	<li><code>preferences[i]</code> 中的所有值都是独一无二的</li>
	<li><code>pairs.length&nbsp;== n/2</code></li>
	<li><code>pairs[i].length&nbsp;== 2</code></li>
	<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n - 1</code></li>
	<li>每位朋友都 <strong>恰好</strong> 被包含在一对中</li>
</ul>
<h1 id="思路分析-15"><a class="header" href="#思路分析-15">思路分析</a></h1>
<p>首先我们要对给入的数据做一个预处理，因为我们在查询亲近程度的时候一定是希望给进两个人，给出一个亲近程度的指数。而题目给我们的数据非常不直观。所以我们可以拿一个二维数组来重新装一下。</p>
<pre><code class="language-rust no_run noplayground"><span class="boring">let n = 10;
</span><span class="boring">let preferences = vec![vec![3]];
</span>let n = n as usize;
let mut pre = vec![vec![0; n]; n];
for i in 0..n {
    for j in 0..(n - 1) {
        pre[i][preferences[i][j] as usize] = n - j - 1;
    }
}
</code></pre>
<p>以上代码将<code>preferences</code>重新整合至<code>pre</code>。这样我们就能很方便的通过<code>pre[i][j]</code>的方式来查询了。</p>
<p>接下来我们仔细观察不开心的示例并且将其改写为代码<br />
<code>pre[x][u] &gt; pre[x][y] &amp;&amp; pre[u][x] &gt; pre[u][v]</code><br />
这个式子非常有意思，不难看出，在满足这个式子的时候，不仅x不满意，u也不满意。<br />
再进一步观察又能发现，这个式子通过<code>x</code>和<code>u</code>是可以完全确定的。所以对于<code>x,y,u,v</code>四个变量来说，这样的两两组合一共有四对。</p>
<pre><code class="language-rust no_run noplayground"><span class="boring">let (a, b, c, d) = (0, 0, 0, 0);
</span><span class="boring">let pre = vec![vec![3]];
</span><span class="boring">let mut set = std::collections::HashSet::new();
</span>if pre[a][c] &gt; pre[a][b] &amp;&amp; pre[c][a] &gt; pre[c][d] {
    set.insert(a);
    set.insert(c);
}
if pre[b][c] &gt; pre[b][a] &amp;&amp; pre[c][b] &gt; pre[c][d] {
    set.insert(b);
    set.insert(c);
}
if pre[b][d] &gt; pre[b][a] &amp;&amp; pre[d][b] &gt; pre[d][c] {
    set.insert(b);
    set.insert(d);
}
if pre[d][a] &gt; pre[d][c] &amp;&amp; pre[a][d] &gt; pre[a][b] {
    set.insert(d);
    set.insert(a);
}
</code></pre>
<p>其中<code>set</code>是为了不重复而设置的哈希集合。（<code>x,y,u,v</code>为了方便写成了<code>a,b,c,d</code>）
然后再对哈希表进行遍历并输出即可。</p>
<h1 id="rust代码-8"><a class="header" href="#rust代码-8">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn unhappy_friends(n: i32, preferences: Vec&lt;Vec&lt;i32&gt;&gt;, pairs: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {
        let n = n as usize;
        let mut pre = vec![vec![0; n]; n];
        for i in 0..n {
            for j in 0..(n - 1) {
                pre[i][preferences[i][j] as usize] = n - j - 1;
            }
        }
        // println!(&quot;{:?}&quot;, pre);
        use std::collections::*;
        let mut set = HashSet::new();
        for i in 0..pairs.len() {
            for j in 0..pairs.len() {
                let a = pairs[i][0] as usize;
                let b = pairs[i][1] as usize;
                let c = pairs[j][0] as usize;
                let d = pairs[j][1] as usize;
                if pre[a][c] &gt; pre[a][b] &amp;&amp; pre[c][a] &gt; pre[c][d] {
                    set.insert(a);
                    set.insert(c);
                }
                if pre[b][c] &gt; pre[b][a] &amp;&amp; pre[c][b] &gt; pre[c][d] {
                    set.insert(b);
                    set.insert(c);
                }
                if pre[b][d] &gt; pre[b][a] &amp;&amp; pre[d][b] &gt; pre[d][c] {
                    set.insert(b);
                    set.insert(d);
                }
                if pre[d][a] &gt; pre[d][c] &amp;&amp; pre[a][d] &gt; pre[a][b] {
                    set.insert(d);
                    set.insert(a);
                }
            }
        }
        set.len() as i32
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no233-数字1的个数"><a class="header" href="#no233-数字1的个数">No.233 数字1的个数</a></h1>
<p>给定一个整数 <code>n</code>，计算所有小于等于 <code>n</code> 的非负整数中数字 <code>1</code> 出现的个数。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 13
<strong>输出：</strong>6
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 0
<strong>输出：</strong>0
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>0 &lt;= n &lt;= 2 * 10<sup>9</sup></code></li>
</ul>
<h1 id="思路分析-16"><a class="header" href="#思路分析-16">思路分析</a></h1>
<pre><code class="language-text">

令a=n/i,b=n%i;
举例分析，假设n=12345，i=100; 此时a=123,b=45：
1）当a的个位大于1时（也就是n的百位），百位为1的数总共出现了(a/10+1)*100次
2）当a为1的时候，百位为1的数总共出现了(a/10)*100+(b+1);
3）当a为0的时候，百位为1的数出现了(a/10)*100次；
因此可以根据a的个位是否为1分成2中情况计算，可以使用一个表达式合并以上三个式子。
a.   9=&gt;(a个位)&gt;=2和0=&lt;(a个位&lt;=1)时的(a/10+1),(a/10)表达式与(a+8)/10等价；
b.  （a&gt;=2时（a+8）/10的结果与a/10+1相同，a==1或a==0时（a+8）/10的结果等价a/10。
c.   当a个位为1时需要加上（b+1）与(a%10==1)*(b+1)等价。因此合并后百位为1的数的个数为
(a+8)/10*i+(a%10==1)*(b+1);
然后令i从个位到最高位遍历即可计算每一位含1的个数；
</code></pre>
<h1 id="rust代码-9"><a class="header" href="#rust代码-9">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn count_digit_one(n: i32) -&gt; i32 {
        let mut cnt = 0;
        let mut i = 1;
        while i &lt;= n {
            let a = n / i;
            let b = n % i;
            cnt += (a + 8) / 10 * i + if a % 10 == 1 {b + 1} else {0};
            i *= 10;
        }
        cnt
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no516-最长回文子序列"><a class="header" href="#no516-最长回文子序列">No.516 最长回文子序列</a></h1>
<p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "bbbab"
<strong>输出：</strong>4
<strong>解释：</strong>一个可能的最长回文子序列为 "bbbb" 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "cbbd"
<strong>输出：</strong>2
<strong>解释：</strong>一个可能的最长回文子序列为 "bb" 。
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h1 id="思路分析-17"><a class="header" href="#思路分析-17">思路分析</a></h1>
<p>其实有一个非常关键的思路。就是<br />
<strong>字符串s的最长回文子序列  等价于  字符串s和s的倒序s'的最长公共子序列</strong></p>
<p>简单的证明，s与s倒序的最长公共子序列一定是回文的。正着有，反着有，且相同，这就是回文的定义。<br />
也不会有比s与s倒序的最长公共子序列更长的回文子序列了。如果有，那么s与s倒序的最长公共子序列也会变得更长。</p>
<p>所以我们成功的将题目转化为求s与s倒序的最长公共子序列的长度。</p>
<p>既然是这样，就非常方便了。直接使用二维动态规划即可轻松求解。
首先设置动态规划变量<code>dp[n+1][n+1]</code>(预留一个空位方便计算)。</p>
<p>再说<code>dp[i][j]</code>的含义，就是s中前i位与s'中前j位的最长公共子序列。</p>
<p>动态规划的递推式也非常好思考。只要遇到了两个相同的字符，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code><br />
否则，<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></p>
<h1 id="rust代码-10"><a class="header" href="#rust代码-10">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn longest_palindrome_subseq(s: String) -&gt; i32 {
        let s = s.into_bytes();
        let n = s.len();
        let mut res = 0;
        let mut dp = vec![vec![0; n + 1]; n + 1];
        for i in 1..=n {
            for j in 1..=n {
                if s[n - i] == s[j - 1] {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = dp[i - 1][j].max(dp[i][j - 1]);
                }
            }
        }

        dp[n][n]
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no446-等差数列划分-ii---子序列"><a class="header" href="#no446-等差数列划分-ii---子序列">No.446 等差数列划分 II - 子序列</a></h1>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中所有 <strong>等差子序列</strong> 的数目。</p>
<p>如果一个序列中 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该序列为等差序列。</p>
<ul>
	<li>例如，<code>[1, 3, 5, 7, 9]</code>、<code>[7, 7, 7, 7]</code> 和 <code>[3, -1, -5, -9]</code> 都是等差序列。</li>
	<li>再例如，<code>[1, 1, 2, 5, 7]</code> 不是等差序列。</li>
</ul>
<p>数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。</p>
<ul>
	<li>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,<em><strong>2</strong></em>,4,1,<strong><em>5</em></strong>,<em><strong>10</strong></em>]</code> 的一个子序列。</li>
</ul>
<p>题目数据保证答案是一个 <strong>32-bit</strong> 整数。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [2,4,6,8,10]
<strong>输出：</strong>7
<strong>解释：</strong>所有的等差子序列为：
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [7,7,7,7,7]
<strong>输出：</strong>16
<strong>解释：</strong>数组中的任意子序列都是等差子序列。
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>1&nbsp; &lt;= nums.length &lt;= 1000</code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
<h1 id="思路分析-18"><a class="header" href="#思路分析-18">思路分析</a></h1>
<p>本题与<a href="2021/8/./10%20-%20No.413%20%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86.html">昨天的题目</a>几乎完全一致。唯一有区别的地方就是将<strong>子数组改成了子序列</strong>。<br />
但这个改动可不是小小的改动，我们之前的思考在这里几乎不会有什么用处。</p>
<p>子序列是没有连续性的，也就是说，对于任意一些有先后顺序但是没有邻接顺序的数字，只要他们满足差值是一个恒定的数，他们就是合法的等差子序列。</p>
<p>首先要理解题目，才有可能做出来。</p>
<p>那么对于子序列，我们能想到的除了暴力还有别的办法吗？<br />
其实答案很简单，我们只需要去提炼一下规律，一个可以总结的规律。<br />
比如在这一题中，如果我们知道<code>[.....,2,4,6]</code>是一个等差数列，那么4前面的东西有多少位与我们并无关系，也就是说，对于后面的数字来说，我们并不关心2前面有几位，因为都是差为2的等差数列。</p>
<p>那么整个数据结构的雏形就出来了，首先外层是一个从前向后的遍历，每一步都会对自己及之前的东西做一个记录，方便后续使用。<br />
记录的这个东西，肯定是基于<strong>等差数列的差</strong>来记录的，我们就使用一个<code>HashMap&lt;i32,?&gt;</code>来记录，那么记录的内容是什么呢？<br />
为了后续使用，我们肯定要想记录数量，也就是<strong>合法的等差子序列的数量</strong>，但是这里又出现了一个问题，长度问题。</p>
<p>长度是一个很关键的点，如果我们记录的是长度为2的，就有可能多算；我们也没有办法只记录长度大于等于3的，因为这必定是基于长度为2的才能推得<br />
在这种情况下，我们使用了<code>HashMap&lt;i32, (i32, i32)&gt;</code>的数据结构。这样可以用前面的<code>i32</code>来记录长度大于等于3的，后面的来记录长度等于2的。</p>
<p>但这里还有一个坑点需要注意，我相信大家也都没发现：<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
这个条件直接导致我们在计算两位之差的时候需要使用比<code>i32</code>更大的数据，否则会溢出。所以我们改用了<code>i64</code>。</p>
<p>然后我们写出了第一版本的代码</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn number_of_arithmetic_slices(nums: Vec&lt;i32&gt;) -&gt; i32 {
        use std::collections::*;
        let mut dp: Vec&lt;HashMap&lt;i64, (i32, i32)&gt;&gt; = vec![];
        let n = nums.len();
        let mut res = 0;
        for i in 0..n {
            let mut nxt = HashMap::new();
            for j in 0..i {
                let diff = nums[i] as i64 - nums[j] as i64;
                if let Some(value) = dp[j].get(&amp;diff) {
                    nxt.entry(diff).or_insert((0, 0)).0 += value.0 + value.1;
                    res += value.0 + value.1;
                }
                nxt.entry(diff).or_insert((0, 0)).1 += 1;
            }
            dp.push(nxt);
        }
        res
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>dp是一个包含每一个位所有信息的一个总和。
在对nums进行遍历的同时，记录所有数据。</p>
<p><code>nxt.entry(diff).or_insert((0, 0)).1 += 1;</code><br />
这句话的意思就是对于所有在i前面的<code>nums[j]</code>都可以与<code>nums[i]</code>组成一个长度为2的组合。所以加到了后面的位。
<code>nxt.entry(diff).or_insert((0, 0)).0 += value.0 + value.1;</code><br />
这句话的意思是如果j位置之前出现过长度大于3或者长度等于2的，再与<code>nums[i]</code>进行搭配，一定会得到一个长度大于等于3的子序列，那么我们就将其加到前面的位上，并且加到答案上。</p>
<p>这段代码是可以通过的，但是我们发现一个要点。在我们使用<code>(i32, i32)</code>时，总是使用它们的和。代码中出现的只有<code>value[0] + value[1]</code>。那么我们是否可以考虑将其合并？</p>
<p>其实也是可以的。合并之后的含义就变化了，<code>HashMap&lt;i64, i32&gt;</code>表示的就是一个特定的diff下长度大于等于2的所有子序列数量。而最令人震惊的是这好像不影响计算。</p>
<h1 id="rust代码-11"><a class="header" href="#rust代码-11">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn number_of_arithmetic_slices(nums: Vec&lt;i32&gt;) -&gt; i32 {
        use std::collections::*;
        let mut dp: Vec&lt;HashMap&lt;i64, i32&gt;&gt; = vec![];
        let n = nums.len();
        let mut res = 0;
        for i in 0..n {
            let mut nxt = HashMap::new();
            for j in 0..i {
                let diff = nums[i] as i64 - nums[j] as i64;
                if let Some(value) = dp[j].get(&amp;diff) {
                    *nxt.entry(diff).or_insert(0) += value;
                    res += value;
                }
                *nxt.entry(diff).or_insert(0) += 1;
            }
            dp.push(nxt);
        }
        res
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>看到了吗？其实答案就是我们在读取前一位的长度为2的子序列的时候，加上这一位一定大于等于3了，所以我们多虑了！<br />
但你要是不试你永远也不知道自己多虑了。 😂</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no413-等差数列划分"><a class="header" href="#no413-等差数列划分">No.413 等差数列划分</a></h1>
<p>如果一个数列 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<ul>
	<li>例如，<code>[1,3,5,7,9]</code>、<code>[7,7,7,7]</code> 和 <code>[3,-1,-5,-9]</code> 都是等差数列。</li>
</ul>
<div class="original__bRMd">
<div>
<p>给你一个整数数组 <code>nums</code> ，返回数组 <code>nums</code> 中所有为等差数组的 <strong>子数组</strong> 个数。</p>
<p><strong>子数组</strong> 是数组中的一个连续序列。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,3,4]
<strong>输出：</strong>3
<strong>解释：</strong>nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1]
<strong>输出：</strong>0
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
	<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
</div>
<h1 id="思路分析-19"><a class="header" href="#思路分析-19">思路分析</a></h1>
<p>子数组一定是在原数组中连续的，所以我们关心的只有原数组中的两两之差。所以可以预处理一下，开一个新的数组存相邻数字的差。<br />
先来思考一个问题，什么样的才能构成等差数列。<br />
答案：字面意思，差相等。那么如果出现连读多个差相等的情况该怎么办呢</p>
<p>根据示例可见，如果出现多个连续的差相等的情况，其实是比较类似排列组合的一个选择，比如<code>[1,2,3,4]</code>和<code>[1,2,3]</code>、<code>[2,3,4]</code>都是合法答案。
如果连续四个数（也就是连续三个缝隙）差相等，就存在三种情况。如果连续<strong>n个数字</strong>呢？</p>
<pre><code class="language-text">1.先假设存在n个可以构成等差数列的数字
例如：1,2,3,4,5,6,7,.....,n（刚好n个）
2.因为最短需要长度为3的子数组，所以长度为3的有n - 2个
3.长度为t的子数组（t&lt;n）有n - t + 1个
4.总共有(n-2)+(n-3)+....+(1)个
还是4.所以总共有(n-2)*(n-1)/2个
</code></pre>
<p>但对于我们来说，计算哪几个数在同一个等差数列很困难，而且存在交叉公用的情况，比如<code>[1,2,3,2,1]</code>中的3，就可能是两个子数组公用的数。<br />
所以我们用<strong>缝隙</strong>来处理，先计算出两两之差（即缝隙），再比较。<br />
将<code>[1,2,3,2,1]</code>处理成<code>[1,1,-1,-1]</code>这样，只要出现两个连续的缝隙，我们就认为可以组成子数组。<br />
这样也很巧妙地处理了公用数字的情况。</p>
<p>那么思路就非常清晰了，我们只需要遍历一遍数组，只关心缝隙，在缝隙连续出现的时候统计，最多连续出现n个缝隙，然后再将答案加上n*(n-1)即可</p>
<h1 id="rust代码-12"><a class="header" href="#rust代码-12">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn number_of_arithmetic_slices(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len();
        let mut res = 0;
        let mut pre = i32::MAX;
        let mut count = 0;
        for i in 1..n {
            let item = nums[i] - nums[i - 1];
            if pre != item {
                if count &gt; 1 {
                    res += count * (count - 1) / 2;
                }
                pre = item;
                count = 1;
            } else {
                count += 1;
            }
        }
        if count &gt; 1 {
            res += count * (count - 1) / 2;
        }
        res
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no313-超级丑数"><a class="header" href="#no313-超级丑数">No.313 超级丑数</a></h1>
<p><strong>超级丑数</strong> 是一个正整数，并满足其所有质因数都出现在质数数组 <code>primes</code> 中。</p>
<p>给你一个整数 <code>n</code> 和一个整数数组 <code>primes</code> ，返回第 <code>n</code> 个 <strong>超级丑数</strong> 。</p>
<p>题目数据保证第 <code>n</code> 个 <strong>超级丑数</strong> 在 <strong>32-bit</strong> 带符号整数范围内。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 12, primes = [2,7,13,19]
<strong>输出：</strong>32 
<strong>解释：</strong>给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 1, primes = [2,3,5]
<strong>输出：</strong>1
<strong>解释：</strong>1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。
</pre>
<p> </p>
<div class="top-view__1vxA">
<div class="original__bRMd">
<div>
<p><strong>提示：</strong></p>
<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= primes.length &lt;= 100</code></li>
	<li><code>2 &lt;= primes[i] &lt;= 1000</code></li>
	<li>题目数据<strong> 保证</strong> <code>primes[i]</code> 是一个质数</li>
	<li><code>primes</code> 中的所有值都 <strong>互不相同</strong> ，且按 <strong>递增顺序</strong> 排列</li>
</ul>
</div>
</div>
</div>
<h1 id="思路分析-20"><a class="header" href="#思路分析-20">思路分析</a></h1>
<p>题目的意思还是比较好理解的，我们需要列出来一个列表（的前n项），这个列表里包括了所有的超级丑数，而我们关心的就是只有第n个超级丑数。
列这个表有许多种思路。比较常见的是优先队列的思路。</p>
<p>优先对列是一个特殊的数据结构，它能保证在其中的所有数字都是有序的。
既然如此，我们可以维护一个优先队列，原始值为<code>[1]</code>，并对它进行n次如下操作:</p>
<pre><code class="language-text">    1.在第n次的时候，从优先队列中取出一个最小的数字t
    2.t即为第n个超级丑数
    3.将t * primes[0], t * primes[1], .....等数字放入优先队列中。
    4.这样就能保证所有超级丑数都曾经被加入过该优先队列，而且因为我们是按照从小到大的顺序取的，所以第二条成立
</code></pre>
<p>按照这个思路，我们可以在<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">im</span><span class="mord mathnormal">es</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">im</span><span class="mord mathnormal">es</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mclose">))</span></span></span></span>的复杂度内计算出第n个超级丑数。</p>
<h1 id="rust代码-13"><a class="header" href="#rust代码-13">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">struct Solution;
</span>impl Solution {
    pub fn nth_super_ugly_number(mut n: i32, primes: Vec&lt;i32&gt;) -&gt; i32 {
        let mut set = BTreeSet::new();
        set.insert(1);
        while set.len() &gt; 0 {
            let first = *set.iter().next().unwrap();
            set.remove(&amp;first);
            for &amp;prime in &amp;primes {
                if (first as i64) * (prime as i64) &lt; (i32::MAX as i64) {
                    set.insert(first * prime);
                }
            }
            n -= 1;
            if n == 0 {
                return first;
            }
        }
        0
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="进阶方法"><a class="header" href="#进阶方法">进阶方法</a></h1>
<h2 id="思路"><a class="header" href="#思路">思路</a></h2>
<p>不难看出，超级丑数数列中的所有项都可以表示为 primes中的一个数和另一个在其之前出现的超级丑数的乘积。<br />
看懂了上面的那个方法之后，也可以看出，我们再每一步将一个超级丑数取出来，乘了一个primes中的数字，再放回到超级丑数的序列中作为候选。<br />
但这样会出现许多冗余和不必要的计算。<br />
比如超级丑数的数列过长，而我们需要的可能只是前几项。<br />
这促使我们找到一个新的方法来计算<br />
因此，我们设立一个新的数组pointer，其中的每一项和primes中的每一项都对应，且初值均为0。在这种情况下，我们也需要将丑数记录在一个名为dp的数列里<br />
在每一次循环中做如下的工作</p>
<pre><code class="language-text">1.计算出当前最小候选超级丑数的值
2.具体的流程为求 dp[pointer[i]] * primes[i] 的最小值(i的取值范围就是primes的长度m)
3.该数即为下一个超级丑数 dp_nxt
4.对于所有项 dp[pointer[i]] * primes[i] == dp_nxt 的i，均使 pointer[i] 增加1
</code></pre>
<p>再理一遍思路，所有超级丑数都是由之前出现过的一个超级丑数乘上primes中的一个数可以获得的。而现在pointer指示的就是之前出现过的超级丑数的位置。<br />
可能出现重复的情况，比如2*9和6*3都会获得18，也就是说为什么对于所有符合最小值的项均需在pointer加1。<br />
按照这种遍历方式，可以从小到大完全遍历所有可能出现的超级丑数，并且省去了很多无效计算。<br />
按照这个思路，我们可以在O(n * primes.length)的时间内完成所有的计算。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">struct Solution;
</span>impl Solution {
    pub fn nth_super_ugly_number(n: i32, primes: Vec&lt;i32&gt;) -&gt; i32 {
        let mut dp = vec![1];
        let n = n as usize;
        let m = primes.len();
        let mut pointer = vec![0; m];
        while dp.len() &lt; n {
            let mut min_pos = 0;
            for i in 1..m {
                if dp[pointer[i]] * primes[i] &lt; dp[pointer[min_pos]] * primes[min_pos] {
                    min_pos = i;
                }
            }
            let tmp = dp[pointer[min_pos]] * primes[min_pos];
            dp.push(tmp);
            for i in 0..m {
                if dp[pointer[i]] * primes[i] == tmp {
                    pointer[i] += 1;
                }
            }
        }
        println!(&quot;{:?}&quot;, dp);
        dp[n - 1]
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="no1137-第n个泰波那契数"><a class="header" href="#no1137-第n个泰波那契数">No.1137 第N个泰波那契数</a></h1>
<p>泰波那契序列&nbsp;T<sub>n</sub>&nbsp;定义如下：&nbsp;</p>
<p>T<sub>0</sub> = 0, T<sub>1</sub> = 1, T<sub>2</sub> = 1, 且在 n &gt;= 0&nbsp;的条件下 T<sub>n+3</sub> = T<sub>n</sub> + T<sub>n+1</sub> + T<sub>n+2</sub></p>
<p>给你整数&nbsp;<code>n</code>，请返回第 n 个泰波那契数&nbsp;T<sub>n </sub>的值。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 4
<strong>输出：</strong>4
<strong>解释：</strong>
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 25
<strong>输出：</strong>1389537
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
	<li><code>0 &lt;= n &lt;= 37</code></li>
	<li>答案保证是一个 32 位整数，即&nbsp;<code>answer &lt;= 2^31 - 1</code>。</li>
</ul>
<h1 id="思路分析-21"><a class="header" href="#思路分析-21">思路分析</a></h1>
<p>通过观察，发现题目要求的是一个数列的和。而且这个数列可以通过前面的3项来计算得到后面的一项。因此我们可以用最简单的暴力算法来做。
也就是我们新建一个数组，里面有固定的三项<code>[0,1,1]</code>。这是题目中给我们的条件，然后我们根据给入的n去计算到我们需要的地方，就可以获得第 N 个泰波那契数了</p>
<h1 id="rust代码-14"><a class="header" href="#rust代码-14">Rust代码</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution;
</span>impl Solution {
    pub fn tribonacci(n: i32) -&gt; i32 {
        let n = n as usize;
        let mut v = vec![0, 1, 1];
        let mut cur_len = 3;
        while cur_len &lt;= n {
            v.push(v[cur_len - 1] + v[cur_len - 2] + v[cur_len - 3]);
            cur_len += 1;
        }
        v[n]
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="运行效果"><a class="header" href="#运行效果">运行效果</a></h1>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">fn main() {
</span><span class="boring">pub fn tribonacci(n: i32) -&gt; i32 {
</span><span class="boring">   let n = n as usize;
</span><span class="boring">   let mut v = vec![0, 1, 1];
</span><span class="boring">   let mut cur_len = 3;
</span><span class="boring">   while cur_len &lt;= n {
</span><span class="boring">       v.push(v[cur_len - 1] + v[cur_len - 2] + v[cur_len - 3]);
</span><span class="boring">       cur_len += 1;
</span><span class="boring">   }
</span><span class="boring">   v[n]
</span><span class="boring">}
</span>println!(&quot;{:?}&quot;, tribonacci(2));
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
